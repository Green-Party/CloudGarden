"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../errors");
const utils_1 = require("../utils");
class VirtualFileSystemHost {
    constructor() {
        this.directories = new utils_1.KeyValueCache();
        this.getOrCreateDir("/");
    }
    isCaseSensitive() {
        return true;
    }
    delete(path) {
        try {
            this.deleteSync(path);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    deleteSync(path) {
        path = utils_1.FileUtils.getStandardizedAbsolutePath(this, path);
        if (this.directories.has(path)) {
            // remove descendant dirs
            for (const descendantDirPath of getDescendantDirectories(this.directories.getKeys(), path))
                this.directories.removeByKey(descendantDirPath);
            // remove this dir
            this.directories.removeByKey(path);
            return;
        }
        const parentDir = this.directories.get(utils_1.FileUtils.getDirPath(path));
        if (parentDir == null || !parentDir.files.has(path))
            throw new errors.FileNotFoundError(path);
        parentDir.files.removeByKey(path);
    }
    readDirSync(dirPath) {
        dirPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, dirPath);
        const dir = this.directories.get(dirPath);
        if (dir == null)
            throw new errors.DirectoryNotFoundError(dirPath);
        return [...getDirectories(this.directories.getKeys()), ...dir.files.getKeys()];
        function* getDirectories(dirPaths) {
            for (const path of dirPaths) {
                const parentDir = utils_1.FileUtils.getDirPath(path);
                if (parentDir === dirPath && parentDir !== path)
                    yield path;
            }
        }
    }
    readFile(filePath, encoding = "utf-8") {
        try {
            return Promise.resolve(this.readFileSync(filePath, encoding));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    readFileSync(filePath, encoding = "utf-8") {
        filePath = utils_1.FileUtils.getStandardizedAbsolutePath(this, filePath);
        const parentDir = this.directories.get(utils_1.FileUtils.getDirPath(filePath));
        if (parentDir == null)
            throw new errors.FileNotFoundError(filePath);
        const fileText = parentDir.files.get(filePath);
        if (fileText === undefined)
            throw new errors.FileNotFoundError(filePath);
        return fileText;
    }
    writeFile(filePath, fileText) {
        this.writeFileSync(filePath, fileText);
        return Promise.resolve();
    }
    writeFileSync(filePath, fileText) {
        filePath = utils_1.FileUtils.getStandardizedAbsolutePath(this, filePath);
        const dirPath = utils_1.FileUtils.getDirPath(filePath);
        this.getOrCreateDir(dirPath).files.set(filePath, fileText);
    }
    mkdir(dirPath) {
        this.mkdirSync(dirPath);
        return Promise.resolve();
    }
    mkdirSync(dirPath) {
        dirPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, dirPath);
        this.getOrCreateDir(dirPath);
    }
    move(srcPath, destPath) {
        this.moveSync(srcPath, destPath);
        return Promise.resolve();
    }
    moveSync(srcPath, destPath) {
        srcPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, srcPath);
        destPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, destPath);
        if (this.fileExistsSync(srcPath)) {
            const fileText = this.readFileSync(srcPath);
            this.deleteSync(srcPath);
            this.writeFileSync(destPath, fileText);
        }
        else if (this.directories.has(srcPath)) {
            const moveDirectory = (from, to) => {
                this._copyDirInternal(from, to);
                this.directories.removeByKey(from);
            };
            moveDirectory(srcPath, destPath);
            // move descendant dirs
            for (const descendantDirPath of getDescendantDirectories(this.directories.getKeys(), srcPath)) {
                const relativePath = utils_1.FileUtils.getRelativePathTo(srcPath, descendantDirPath);
                moveDirectory(descendantDirPath, utils_1.FileUtils.pathJoin(destPath, relativePath));
            }
        }
        else
            throw new errors.PathNotFoundError(srcPath);
    }
    copy(srcPath, destPath) {
        this.copySync(srcPath, destPath);
        return Promise.resolve();
    }
    copySync(srcPath, destPath) {
        srcPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, srcPath);
        destPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, destPath);
        if (this.fileExistsSync(srcPath))
            this.writeFileSync(destPath, this.readFileSync(srcPath));
        else if (this.directories.has(srcPath)) {
            this._copyDirInternal(srcPath, destPath);
            // copy descendant dirs
            for (const descendantDirPath of getDescendantDirectories(this.directories.getKeys(), srcPath)) {
                const relativePath = utils_1.FileUtils.getRelativePathTo(srcPath, descendantDirPath);
                this._copyDirInternal(descendantDirPath, utils_1.FileUtils.pathJoin(destPath, relativePath));
            }
        }
        else
            throw new errors.PathNotFoundError(srcPath);
    }
    _copyDirInternal(from, to) {
        const dir = this.directories.get(from);
        const newDir = this.getOrCreateDir(to);
        for (const fileEntry of dir.files.getEntries())
            newDir.files.set(utils_1.FileUtils.pathJoin(to, utils_1.FileUtils.getBaseName(fileEntry[0])), fileEntry[1]);
    }
    fileExists(filePath) {
        return Promise.resolve(this.fileExistsSync(filePath));
    }
    fileExistsSync(filePath) {
        filePath = utils_1.FileUtils.getStandardizedAbsolutePath(this, filePath);
        const dirPath = utils_1.FileUtils.getDirPath(filePath);
        const dir = this.directories.get(dirPath);
        if (dir == null)
            return false;
        return dir.files.has(filePath);
    }
    directoryExists(dirPath) {
        return Promise.resolve(this.directoryExistsSync(dirPath));
    }
    directoryExistsSync(dirPath) {
        dirPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, dirPath);
        return this.directories.has(dirPath);
    }
    realpathSync(path) {
        return path;
    }
    getCurrentDirectory() {
        return "/";
    }
    glob(patterns) {
        const filePaths = [];
        const allFilePaths = Array.from(getAllFilePaths(this.directories.getValues()));
        return utils_1.matchGlobs(allFilePaths, patterns, this.getCurrentDirectory());
        function* getAllFilePaths(directories) {
            for (const dir of directories) {
                yield* dir.files.getKeys();
            }
        }
    }
    getOrCreateDir(dirPath) {
        let dir = this.directories.get(dirPath);
        if (dir == null) {
            dir = { path: dirPath, files: new utils_1.KeyValueCache() };
            this.directories.set(dirPath, dir);
            const parentDirPath = utils_1.FileUtils.getDirPath(dirPath);
            if (parentDirPath !== dirPath)
                this.getOrCreateDir(parentDirPath);
        }
        return dir;
    }
}
exports.VirtualFileSystemHost = VirtualFileSystemHost;
function* getDescendantDirectories(directoryPaths, dirPath) {
    for (const path of directoryPaths) {
        if (utils_1.FileUtils.pathStartsWith(path, dirPath))
            yield path;
    }
}
