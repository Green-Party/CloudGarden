"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../errors");
const utils_1 = require("../utils");
class Directory {
    constructor(path) {
        this.path = path;
        this.operations = [];
        this.inboundOperations = [];
        this.isDeleted = false;
        this.wasEverDeleted = false;
        this.childDirs = new utils_1.SortedKeyValueArray(item => item.path, utils_1.LocaleStringComparer.instance);
    }
    getExternalOperations() {
        return [
            ...utils_1.ArrayUtils.flatten(this.getAncestors().map(a => getMoveCopyOrDeleteOperations(a))).filter(o => isAncestorAffectedOperation(this, o)),
            ...utils_1.ArrayUtils.flatten([this, ...this.getDescendants()].map(d => getMoveOrCopyOperations(d))).filter(o => !isInternalOperation(this, o))
        ];
        function isInternalOperation(thisDir, operation) {
            return operation.oldDir.isDescendantOrEqual(thisDir) && operation.newDir.isDescendantOrEqual(thisDir);
        }
        function isAncestorAffectedOperation(thisDir, operation) {
            switch (operation.kind) {
                case "move":
                case "copy":
                    return thisDir.isDescendantOrEqual(operation.oldDir) || thisDir.isDescendantOrEqual(operation.newDir);
                case "deleteDir":
                    return thisDir.isDescendantOrEqual(operation.dir);
                default:
                    return errors.throwNotImplementedForNeverValueError(operation);
            }
        }
        function getMoveOrCopyOperations(dir) {
            return dir.operations.filter(o => o.kind === "move" || o.kind === "copy");
        }
        function getMoveCopyOrDeleteOperations(dir) {
            return dir.operations.filter(o => o.kind === "move" || o.kind === "deleteDir" || o.kind === "copy");
        }
    }
    isDescendantOrEqual(directory) {
        return this.isDescendant(directory) || this === directory;
    }
    isDescendant(directory) {
        return utils_1.FileUtils.pathStartsWith(this.path, directory.path);
    }
    getIsDeleted() {
        return this.isDeleted;
    }
    getWasEverDeleted() {
        if (this.wasEverDeleted)
            return true;
        for (const ancestor of this.getAncestorsIterator()) {
            if (ancestor.wasEverDeleted)
                return true;
        }
        return false;
    }
    setIsDeleted(isDeleted) {
        if (this.isDeleted === isDeleted)
            return;
        if (isDeleted) {
            this.wasEverDeleted = true;
            for (const child of this.childDirs.entries())
                child.setIsDeleted(true);
        }
        else {
            if (this.parent != null)
                this.parent.setIsDeleted(false);
        }
        this.isDeleted = isDeleted;
    }
    getParent() {
        return this.parent;
    }
    setParent(parent) {
        if (this.parent != null)
            throw new errors.InvalidOperationError("For some reason, a parent was being set when the directory already had a parent. Please open an issue.");
        this.parent = parent;
        parent.childDirs.set(this);
        if (parent.isDeleted && !this.isDeleted)
            parent.setIsDeleted(false);
    }
    removeParent() {
        const parent = this.parent;
        if (parent == null)
            return;
        parent.childDirs.removeByValue(this);
        this.parent = undefined;
    }
    getAncestors() {
        return Array.from(this.getAncestorsIterator());
    }
    *getAncestorsIterator() {
        let parent = this.parent;
        while (parent != null) {
            yield parent;
            parent = parent.parent;
        }
    }
    getDescendants() {
        const descendants = [];
        for (const child of this.childDirs.entries()) {
            descendants.push(child);
            descendants.push(...child.getDescendants());
        }
        return descendants;
    }
    isFileQueuedForDelete(filePath) {
        return this.hasOperation(operation => operation.kind === "deleteFile" && operation.filePath === filePath);
    }
    hasOperation(operationMatches) {
        for (const operation of this.operations) {
            if (operationMatches(operation))
                return true;
        }
        return false;
    }
    dequeueFileDelete(filePath) {
        this.removeMatchingOperations(operation => operation.kind === "deleteFile" && operation.filePath === filePath);
    }
    dequeueDirDelete(dirPath) {
        this.removeMatchingOperations(operation => operation.kind === "deleteDir" && operation.dir.path === dirPath);
    }
    isRootDir() {
        return utils_1.FileUtils.isRootDirPath(this.path);
    }
    removeMatchingOperations(operationMatches) {
        utils_1.ArrayUtils.removeAll(this.operations, operationMatches);
    }
}
/**
 * File system host wrapper that allows queuing deletions to the file system.
 */
class FileSystemWrapper {
    constructor(fileSystem) {
        this.fileSystem = fileSystem;
        this.directories = new utils_1.KeyValueCache();
        this.operationIndex = 0;
        this.pathCasingMaintainer = new PathCasingMaintainer(fileSystem);
    }
    queueFileDelete(filePath) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        const parentDir = this.getOrCreateParentDirectory(filePath);
        parentDir.operations.push({
            kind: "deleteFile",
            index: this.getNextOperationIndex(),
            filePath
        });
    }
    removeFileDelete(filePath) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        this.getOrCreateParentDirectory(filePath).dequeueFileDelete(filePath);
    }
    queueMkdir(dirPath) {
        dirPath = this.getStandardizedAbsolutePath(dirPath);
        const dir = this.getOrCreateDirectory(dirPath);
        dir.setIsDeleted(false);
        const parentDir = this.getOrCreateParentDirectory(dirPath);
        parentDir.operations.push({
            kind: "mkdir",
            index: this.getNextOperationIndex(),
            dir
        });
    }
    queueDirectoryDelete(dirPath) {
        dirPath = this.getStandardizedAbsolutePath(dirPath);
        const dir = this.getOrCreateDirectory(dirPath);
        dir.setIsDeleted(true);
        const parentDir = this.getOrCreateParentDirectory(dirPath);
        parentDir.operations.push({
            kind: "deleteDir",
            index: this.getNextOperationIndex(),
            dir
        });
    }
    queueMoveDirectory(srcPath, destPath) {
        // todo: tests for the root directory
        srcPath = this.getStandardizedAbsolutePath(srcPath);
        destPath = this.getStandardizedAbsolutePath(destPath);
        const parentDir = this.getOrCreateParentDirectory(srcPath);
        const moveDir = this.getOrCreateDirectory(srcPath);
        const destinationDir = this.getOrCreateDirectory(destPath);
        const moveOperation = {
            kind: "move",
            index: this.getNextOperationIndex(),
            oldDir: moveDir,
            newDir: destinationDir
        };
        parentDir.operations.push(moveOperation);
        (destinationDir.getParent() || destinationDir).inboundOperations.push(moveOperation);
        moveDir.setIsDeleted(true);
    }
    queueCopyDirectory(srcPath, destPath) {
        srcPath = this.getStandardizedAbsolutePath(srcPath);
        destPath = this.getStandardizedAbsolutePath(destPath);
        const parentDir = this.getOrCreateParentDirectory(srcPath);
        const copyDir = this.getOrCreateDirectory(srcPath);
        const destinationDir = this.getOrCreateDirectory(destPath);
        const copyOperation = {
            kind: "copy",
            index: this.getNextOperationIndex(),
            oldDir: copyDir,
            newDir: destinationDir
        };
        parentDir.operations.push(copyOperation);
        (destinationDir.getParent() || destinationDir).inboundOperations.push(copyOperation);
    }
    flush() {
        return __awaiter(this, void 0, void 0, function* () {
            const operations = this.getAndClearOperations();
            for (const operation of operations)
                yield this.executeOperation(operation);
        });
    }
    flushSync() {
        for (const operation of this.getAndClearOperations())
            this.executeOperationSync(operation);
    }
    saveForDirectory(dirPath) {
        return __awaiter(this, void 0, void 0, function* () {
            dirPath = this.getStandardizedAbsolutePath(dirPath);
            const dir = this.getOrCreateDirectory(dirPath);
            this.throwIfHasExternalOperations(dir, "save directory");
            const operations = this.getAndClearOperationsForDir(dir);
            // await after the state is set
            yield this.ensureDirectoryExists(dir);
            for (const operation of operations)
                yield this.executeOperation(operation);
        });
    }
    saveForDirectorySync(dirPath) {
        dirPath = this.getStandardizedAbsolutePath(dirPath);
        const dir = this.getOrCreateDirectory(dirPath);
        this.throwIfHasExternalOperations(dir, "save directory");
        this.ensureDirectoryExistsSync(dir);
        for (const operation of this.getAndClearOperationsForDir(dir))
            this.executeOperationSync(operation);
    }
    getAndClearOperationsForDir(dir) {
        const operations = getAndClearParentMkDirOperations(dir.getParent(), dir);
        for (const currentDir of [dir, ...dir.getDescendants()])
            operations.push(...currentDir.operations);
        utils_1.ArrayUtils.sortByProperty(operations, item => item.index);
        this.removeDirAndSubDirs(dir);
        return operations;
        function getAndClearParentMkDirOperations(parentDir, childDir) {
            if (parentDir == null)
                return [];
            const parentOperations = utils_1.ArrayUtils.removeAll(parentDir.operations, operation => operation.kind === "mkdir" && operation.dir === childDir);
            return [...parentOperations, ...getAndClearParentMkDirOperations(parentDir.getParent(), parentDir)];
        }
    }
    executeOperation(operation) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (operation.kind) {
                case "deleteDir":
                    yield this.deleteSuppressNotFound(operation.dir.path);
                    break;
                case "deleteFile":
                    yield this.deleteSuppressNotFound(operation.filePath);
                    break;
                case "move":
                    yield this.fileSystem.move(operation.oldDir.path, operation.newDir.path);
                    break;
                case "copy":
                    yield this.fileSystem.copy(operation.oldDir.path, operation.newDir.path);
                    break;
                case "mkdir":
                    yield this.fileSystem.mkdir(operation.dir.path);
                    break;
                default:
                    errors.throwNotImplementedForNeverValueError(operation);
            }
        });
    }
    executeOperationSync(operation) {
        switch (operation.kind) {
            case "deleteDir":
                this.deleteSuppressNotFoundSync(operation.dir.path);
                break;
            case "deleteFile":
                this.deleteSuppressNotFoundSync(operation.filePath);
                break;
            case "move":
                this.fileSystem.moveSync(operation.oldDir.path, operation.newDir.path);
                break;
            case "copy":
                this.fileSystem.copySync(operation.oldDir.path, operation.newDir.path);
                break;
            case "mkdir":
                this.fileSystem.mkdirSync(operation.dir.path);
                break;
            default:
                errors.throwNotImplementedForNeverValueError(operation);
        }
    }
    getAndClearOperations() {
        const operations = [];
        for (const dir of this.directories.getValues())
            operations.push(...dir.operations);
        utils_1.ArrayUtils.sortByProperty(operations, item => item.index);
        this.directories.clear();
        return operations;
    }
    moveFileImmediately(oldFilePath, newFilePath, fileText) {
        return __awaiter(this, void 0, void 0, function* () {
            oldFilePath = this.getStandardizedAbsolutePath(oldFilePath);
            newFilePath = this.getStandardizedAbsolutePath(newFilePath);
            this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(oldFilePath), "move file");
            this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(newFilePath), "move file");
            yield this.deleteFileImmediately(oldFilePath);
            yield this.writeFile(newFilePath, fileText);
        });
    }
    moveFileImmediatelySync(oldFilePath, newFilePath, fileText) {
        oldFilePath = this.getStandardizedAbsolutePath(oldFilePath);
        newFilePath = this.getStandardizedAbsolutePath(newFilePath);
        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(oldFilePath), "move file");
        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(newFilePath), "move file");
        this.deleteFileImmediatelySync(oldFilePath);
        this.writeFileSync(newFilePath, fileText);
    }
    deleteFileImmediately(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            filePath = this.getStandardizedAbsolutePath(filePath);
            const dir = this.getOrCreateParentDirectory(filePath);
            this.throwIfHasExternalOperations(dir, "delete file");
            dir.dequeueFileDelete(filePath);
            try {
                yield this.deleteSuppressNotFound(filePath);
            }
            catch (err) {
                this.queueFileDelete(filePath);
                throw err;
            }
        });
    }
    deleteFileImmediatelySync(filePath) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        const dir = this.getOrCreateParentDirectory(filePath);
        this.throwIfHasExternalOperations(dir, "delete file");
        dir.dequeueFileDelete(filePath);
        try {
            this.deleteSuppressNotFoundSync(filePath);
        }
        catch (err) {
            this.queueFileDelete(filePath);
            throw err;
        }
    }
    copyDirectoryImmediately(srcDirPath, destDirPath) {
        return __awaiter(this, void 0, void 0, function* () {
            srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);
            destDirPath = this.getStandardizedAbsolutePath(destDirPath);
            const srcDir = this.getOrCreateDirectory(srcDirPath);
            const destDir = this.getOrCreateDirectory(destDirPath);
            this.throwIfHasExternalOperations(srcDir, "copy directory");
            this.throwIfHasExternalOperations(destDir, "copy directory");
            const saveTask = Promise.all([this.saveForDirectory(srcDirPath), this.saveForDirectory(destDirPath)]);
            this.removeDirAndSubDirs(srcDir);
            // await after the state is set
            yield saveTask;
            yield this.fileSystem.copy(srcDirPath, destDirPath);
        });
    }
    copyDirectoryImmediatelySync(srcDirPath, destDirPath) {
        srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);
        destDirPath = this.getStandardizedAbsolutePath(destDirPath);
        const srcDir = this.getOrCreateDirectory(srcDirPath);
        const destDir = this.getOrCreateDirectory(destDirPath);
        this.throwIfHasExternalOperations(srcDir, "copy directory");
        this.throwIfHasExternalOperations(destDir, "copy directory");
        this.saveForDirectorySync(srcDirPath);
        this.saveForDirectorySync(destDirPath);
        this.removeDirAndSubDirs(srcDir);
        this.fileSystem.copySync(srcDirPath, destDirPath);
    }
    moveDirectoryImmediately(srcDirPath, destDirPath) {
        return __awaiter(this, void 0, void 0, function* () {
            srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);
            destDirPath = this.getStandardizedAbsolutePath(destDirPath);
            const srcDir = this.getOrCreateDirectory(srcDirPath);
            const destDir = this.getOrCreateDirectory(destDirPath);
            this.throwIfHasExternalOperations(srcDir, "move directory");
            this.throwIfHasExternalOperations(destDir, "move directory");
            const saveTask = Promise.all([this.saveForDirectory(srcDirPath), this.saveForDirectory(destDirPath)]);
            this.removeDirAndSubDirs(srcDir);
            // await after the state is set
            yield saveTask;
            yield this.fileSystem.move(srcDirPath, destDirPath);
        });
    }
    moveDirectoryImmediatelySync(srcDirPath, destDirPath) {
        srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);
        destDirPath = this.getStandardizedAbsolutePath(destDirPath);
        const srcDir = this.getOrCreateDirectory(srcDirPath);
        const destDir = this.getOrCreateDirectory(destDirPath);
        this.throwIfHasExternalOperations(srcDir, "move directory");
        this.throwIfHasExternalOperations(destDir, "move directory");
        this.saveForDirectorySync(srcDirPath);
        this.saveForDirectorySync(destDirPath);
        this.removeDirAndSubDirs(srcDir);
        this.fileSystem.moveSync(srcDirPath, destDirPath);
    }
    deleteDirectoryImmediately(dirPath) {
        return __awaiter(this, void 0, void 0, function* () {
            dirPath = this.getStandardizedAbsolutePath(dirPath);
            const dir = this.getOrCreateDirectory(dirPath);
            this.throwIfHasExternalOperations(dir, "delete");
            this.removeDirAndSubDirs(dir);
            try {
                yield this.deleteSuppressNotFound(dirPath);
            }
            catch (err) {
                this.addBackDirAndSubDirs(dir);
                this.queueDirectoryDelete(dirPath);
            }
        });
    }
    deleteDirectoryImmediatelySync(dirPath) {
        dirPath = this.getStandardizedAbsolutePath(dirPath);
        const dir = this.getOrCreateDirectory(dirPath);
        this.throwIfHasExternalOperations(dir, "delete");
        this.removeDirAndSubDirs(dir);
        try {
            this.deleteSuppressNotFoundSync(dirPath);
        }
        catch (err) {
            this.addBackDirAndSubDirs(dir);
            this.queueDirectoryDelete(dirPath);
        }
    }
    deleteSuppressNotFound(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.fileSystem.delete(path);
            }
            catch (err) {
                if (!utils_1.FileUtils.isNotExistsError(err))
                    throw err;
            }
        });
    }
    deleteSuppressNotFoundSync(path) {
        try {
            this.fileSystem.deleteSync(path);
        }
        catch (err) {
            if (!utils_1.FileUtils.isNotExistsError(err))
                throw err;
        }
    }
    fileExistsSync(filePath) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        if (this.isPathQueuedForDeletion(filePath))
            return false;
        const parentDir = this.getParentDirectoryIfExists(filePath);
        if (parentDir != null && parentDir.getWasEverDeleted())
            return false;
        return this.fileSystem.fileExistsSync(filePath);
    }
    directoryExistsSync(dirPath) {
        dirPath = this.getStandardizedAbsolutePath(dirPath);
        if (this.isPathQueuedForDeletion(dirPath))
            return false;
        if (this.isPathDirectoryInQueueThatExists(dirPath))
            return true;
        const dir = this.getDirectoryIfExists(dirPath);
        if (dir != null && dir.getWasEverDeleted())
            return false;
        return this.fileSystem.directoryExistsSync(dirPath);
    }
    readFileSync(filePath, encoding) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        if (this.isPathQueuedForDeletion(filePath))
            throw new errors.InvalidOperationError(`Cannot read file at ${filePath} when it is queued for deletion.`);
        if (this.getOrCreateParentDirectory(filePath).getWasEverDeleted())
            throw new errors.InvalidOperationError(`Cannot read file at ${filePath} because one of its ancestor directories was once deleted or moved.`);
        return this.fileSystem.readFileSync(filePath, encoding);
    }
    readDirSync(dirPath) {
        dirPath = this.getStandardizedAbsolutePath(dirPath);
        const dir = this.getOrCreateDirectory(dirPath);
        if (dir.getIsDeleted())
            throw new errors.InvalidOperationError(`Cannot read directory at ${dirPath} when it is queued for deletion.`);
        if (dir.getWasEverDeleted())
            throw new errors.InvalidOperationError(`Cannot read directory at ${dirPath} because one of its ancestor directories was once deleted or moved.`);
        return this.fileSystem.readDirSync(dirPath).filter(path => !this.isPathQueuedForDeletion(path) && !this.isPathQueuedForDeletion(path));
    }
    glob(patterns) {
        return this.fileSystem.glob(patterns).filter(path => !this.isPathQueuedForDeletion(path));
    }
    getFileSystem() {
        return this.fileSystem;
    }
    getCurrentDirectory() {
        return this.fileSystem.getCurrentDirectory();
    }
    getDirectories(dirPath) {
        return this.readDirSync(dirPath).filter(path => this.directoryExistsSync(path));
    }
    realpathSync(path) {
        return this.getStandardizedAbsolutePath(this.fileSystem.realpathSync(path));
    }
    getStandardizedAbsolutePath(fileOrDirPath, relativeBase) {
        fileOrDirPath = utils_1.FileUtils.getStandardizedAbsolutePath(this.fileSystem, fileOrDirPath, relativeBase);
        return this.pathCasingMaintainer.getPath(fileOrDirPath);
    }
    readFileOrNotExists(filePath, encoding) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        if (this.isPathQueuedForDeletion(filePath))
            return false;
        return utils_1.FileUtils.readFileOrNotExists(this.fileSystem, filePath, encoding);
    }
    readFileOrNotExistsSync(filePath, encoding) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        if (this.isPathQueuedForDeletion(filePath))
            return false;
        return utils_1.FileUtils.readFileOrNotExistsSync(this.fileSystem, filePath, encoding);
    }
    writeFile(filePath, fileText) {
        return __awaiter(this, void 0, void 0, function* () {
            filePath = this.getStandardizedAbsolutePath(filePath);
            const parentDir = this.getOrCreateParentDirectory(filePath);
            this.throwIfHasExternalOperations(parentDir, "write file");
            parentDir.dequeueFileDelete(filePath);
            yield this.ensureDirectoryExists(parentDir);
            yield this.fileSystem.writeFile(filePath, fileText);
        });
    }
    writeFileSync(filePath, fileText) {
        filePath = this.getStandardizedAbsolutePath(filePath);
        const parentDir = this.getOrCreateParentDirectory(filePath);
        this.throwIfHasExternalOperations(parentDir, "write file");
        parentDir.dequeueFileDelete(filePath);
        this.ensureDirectoryExistsSync(parentDir);
        this.fileSystem.writeFileSync(filePath, fileText);
    }
    isPathDirectoryInQueueThatExists(path) {
        const pathDir = this.getDirectoryIfExists(path);
        return pathDir == null ? false : !pathDir.getIsDeleted();
    }
    isPathQueuedForDeletion(path) {
        // check if the provided path is a dir and if it's deleted
        const pathDir = this.getDirectoryIfExists(path);
        if (pathDir != null)
            return pathDir.getIsDeleted();
        // check if the provided path is a file or if it or its parent is deleted
        const parentDir = this.getOrCreateParentDirectory(path);
        return parentDir.isFileQueuedForDelete(path) || parentDir.getIsDeleted();
    }
    removeDirAndSubDirs(dir) {
        const originalParent = dir.getParent();
        dir.removeParent();
        for (const dirToRemove of [dir, ...dir.getDescendants()])
            this.directories.removeByKey(dirToRemove.path);
        if (originalParent != null)
            originalParent.dequeueDirDelete(dir.path);
    }
    addBackDirAndSubDirs(dir) {
        for (const dirToAdd of [dir, ...dir.getDescendants()])
            this.directories.set(dirToAdd.path, dirToAdd);
        if (!dir.isRootDir())
            dir.setParent(this.getOrCreateParentDirectory(dir.path));
    }
    getNextOperationIndex() {
        return this.operationIndex++;
    }
    getParentDirectoryIfExists(filePath) {
        return this.getDirectoryIfExists(utils_1.FileUtils.getDirPath(filePath));
    }
    getOrCreateParentDirectory(filePath) {
        return this.getOrCreateDirectory(utils_1.FileUtils.getDirPath(filePath));
    }
    getDirectoryIfExists(dirPath) {
        return this.directories.get(dirPath);
    }
    getOrCreateDirectory(dirPath) {
        let dir = this.directories.get(dirPath);
        if (dir != null)
            return dir;
        const getOrCreateDir = (creatingDirPath) => this.directories.getOrCreate(creatingDirPath, () => new Directory(creatingDirPath));
        dir = getOrCreateDir(dirPath);
        let currentDirPath = dirPath;
        let currentDir = dir;
        while (!utils_1.FileUtils.isRootDirPath(currentDirPath)) {
            const nextDirPath = utils_1.FileUtils.getDirPath(currentDirPath);
            const hadNextDir = this.directories.has(nextDirPath);
            const nextDir = getOrCreateDir(nextDirPath);
            currentDir.setParent(nextDir);
            if (hadNextDir)
                return dir;
            currentDir = nextDir;
            currentDirPath = nextDirPath;
        }
        return dir;
    }
    throwIfHasExternalOperations(dir, commandName) {
        const operations = dir.getExternalOperations();
        if (operations.length === 0)
            return;
        throw new errors.InvalidOperationError(getErrorText());
        function getErrorText() {
            let hasCopy = false;
            let errorText = `Cannot execute immediate operation '${commandName}' because of the following external operations:\n`;
            for (const operation of operations) {
                if (operation.kind === "move")
                    errorText += `\n* Move: ${operation.oldDir.path} --> ${operation.newDir.path}`;
                else if (operation.kind === "copy") {
                    errorText += `\n* Copy: ${operation.oldDir.path} --> ${operation.newDir.path}`;
                    hasCopy = true;
                }
                else if (operation.kind === "deleteDir")
                    errorText += `\n* Delete: ${operation.dir.path}`;
                else {
                    const expectNever = operation;
                    errorText += `\n* Unknown operation: Please report this as a bug.`;
                }
            }
            if (hasCopy)
                errorText += "\n\nNote: Copy operations can be removed from external operations by setting `includeUntrackedFiles` to `false` when copying.";
            return errorText;
        }
    }
    ensureDirectoryExists(dir) {
        return __awaiter(this, void 0, void 0, function* () {
            if (dir.isRootDir())
                return;
            this.removeMkDirOperationsForDir(dir);
            yield this.fileSystem.mkdir(dir.path);
        });
    }
    ensureDirectoryExistsSync(dir) {
        if (dir.isRootDir())
            return;
        this.removeMkDirOperationsForDir(dir);
        this.fileSystem.mkdirSync(dir.path);
    }
    removeMkDirOperationsForDir(dir) {
        const parentDir = dir.getParent();
        if (parentDir != null) {
            utils_1.ArrayUtils.removeAll(parentDir.operations, operation => operation.kind === "mkdir" && operation.dir === dir);
            this.removeMkDirOperationsForDir(parentDir);
        }
    }
}
exports.FileSystemWrapper = FileSystemWrapper;
/** Maintains the file or dir path casing by using the first file path found for case insensistive file systems. */
class PathCasingMaintainer {
    constructor(fileSystem) {
        if (fileSystem.isCaseSensitive != null && !fileSystem.isCaseSensitive())
            this.caseInsensitiveMappings = new utils_1.KeyValueCache();
    }
    getPath(fileOrDirPath) {
        if (this.caseInsensitiveMappings == null)
            return fileOrDirPath;
        return this.caseInsensitiveMappings.getOrCreate(fileOrDirPath.toLowerCase(), () => fileOrDirPath);
    }
}
