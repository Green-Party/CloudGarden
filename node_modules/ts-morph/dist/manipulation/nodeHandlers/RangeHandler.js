"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const NodeHandlerHelper_1 = require("./NodeHandlerHelper");
const StraightReplacementNodeHandler_1 = require("./StraightReplacementNodeHandler");
/**
 * Handler for deailing with a node that is going to have a descendant replaced based on the range.
 */
class RangeHandler {
    // private readonly replacingLength: number | undefined;
    constructor(compilerFactory, opts) {
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);
        this.start = opts.start;
        this.end = opts.end;
        // this.replacingLength = opts.replacingLength;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        const children = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        const currentNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(children[0]));
        const newNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(children[1]));
        // get the first child
        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.start)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        // go down into the children if before the node or in a surrounding node
        while (!currentNodeChildren.done && !newNodeChildren.done
            && (currentNodeChildren.peek.getStart(currentSourceFile) < this.start
                || currentNodeChildren.peek.getStart(currentSourceFile) === this.start && newNodeChildren.peek.end > this.end)) {
            this.rangeHandlerReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        }
        // skip over the new children while they're within the range
        while (!newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.end)
            newNodeChildren.next();
        // handle the rest
        while (!currentNodeChildren.done)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        // ensure the new children iterator is done too
        if (!newNodeChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    straightReplace(currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this.straightReplacementNodeHandler, currentNode, nextNode, newSourceFile);
    }
    rangeHandlerReplace(currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this, currentNode, nextNode, newSourceFile);
    }
}
exports.RangeHandler = RangeHandler;
