"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../errors");
const utils_1 = require("../../utils");
const NodeHandlerHelper_1 = require("./NodeHandlerHelper");
/**
 * Replacement handler for replacing parts of the tree that should be equal.
 */
class StraightReplacementNodeHandler {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);
    }
    handleNode(currentNode, newNode, newSourceFile) {
        /* istanbul ignore if */
        if (currentNode.getKind() !== newNode.kind)
            throw new errors.InvalidOperationError(`Error replacing tree! Perhaps a syntax error was inserted ` +
                `(Current: ${currentNode.getKindName()} -- New: ${utils_1.getSyntaxKindName(newNode.kind)}).`);
        if (currentNode._hasWrappedChildren())
            this.handleChildren(currentNode, newNode, newSourceFile);
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleChildren(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        if (currentChildren.length !== newChildren.length)
            throw new Error(`Error replacing tree: The children of the old and new trees were expected to have the same count (${currentChildren.length}:${newChildren.length}).`);
        for (let i = 0; i < currentChildren.length; i++)
            this.helper.handleForValues(this, currentChildren[i], newChildren[i], newSourceFile);
    }
}
exports.StraightReplacementNodeHandler = StraightReplacementNodeHandler;
