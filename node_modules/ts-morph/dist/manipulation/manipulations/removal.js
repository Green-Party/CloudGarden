"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("../../typescript");
const utils_1 = require("../../utils");
const formatting_1 = require("../formatting");
const nodeHandlers_1 = require("../nodeHandlers");
const textManipulators_1 = require("../textManipulators");
const doManipulation_1 = require("./doManipulation");
function removeChildren(opts) {
    const { children } = opts;
    if (children.length === 0)
        return;
    doManipulation_1.doManipulation(children[0].getSourceFile(), new textManipulators_1.RemoveChildrenTextManipulator(opts), new nodeHandlers_1.NodeHandlerFactory().getForChildIndex({
        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),
        childIndex: children[0].getChildIndex(),
        childCount: -1 * children.length
    }));
}
exports.removeChildren = removeChildren;
function removeChildrenWithFormattingFromCollapsibleSyntaxList(opts) {
    const { children } = opts;
    if (children.length === 0)
        return;
    const syntaxList = children[0].getParentSyntaxListOrThrow();
    if (syntaxList.getChildCount() === children.length) {
        removeChildrenWithFormatting({
            children: [syntaxList],
            getSiblingFormatting: () => formatting_1.FormattingKind.None
        });
    }
    else
        removeChildrenWithFormatting(opts);
}
exports.removeChildrenWithFormattingFromCollapsibleSyntaxList = removeChildrenWithFormattingFromCollapsibleSyntaxList;
function removeChildrenWithFormatting(opts) {
    const { children, getSiblingFormatting } = opts;
    if (children.length === 0)
        return;
    doManipulation_1.doManipulation(children[0]._sourceFile, new textManipulators_1.RemoveChildrenWithFormattingTextManipulator({
        children,
        getSiblingFormatting
    }), new nodeHandlers_1.NodeHandlerFactory().getForChildIndex({
        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),
        childIndex: children[0].getChildIndex(),
        childCount: -1 * children.length
    }));
}
exports.removeChildrenWithFormatting = removeChildrenWithFormatting;
function removeClassMember(classMember) {
    if (utils_1.TypeGuards.isOverloadableNode(classMember)) {
        if (classMember.isImplementation()) {
            removeClassMembers([...classMember.getOverloads(), classMember]);
        }
        else {
            const parent = classMember.getParentOrThrow();
            if (utils_1.TypeGuards.isAmbientableNode(parent) && parent.isAmbient())
                removeClassMembers([classMember]);
            else
                removeChildren({ children: [classMember], removeFollowingSpaces: true, removeFollowingNewLines: true });
        }
    }
    else {
        removeClassMembers([classMember]);
    }
}
exports.removeClassMember = removeClassMember;
function removeClassMembers(classMembers) {
    removeChildrenWithFormatting({
        getSiblingFormatting: formatting_1.getClassMemberFormatting,
        children: classMembers
    });
}
exports.removeClassMembers = removeClassMembers;
function removeInterfaceMember(interfaceMember) {
    removeInterfaceMembers([interfaceMember]);
}
exports.removeInterfaceMember = removeInterfaceMember;
function removeInterfaceMembers(interfaceMembers) {
    removeChildrenWithFormatting({
        getSiblingFormatting: formatting_1.getInterfaceMemberFormatting,
        children: interfaceMembers
    });
}
exports.removeInterfaceMembers = removeInterfaceMembers;
function removeCommaSeparatedChild(child) {
    const childrenToRemove = [child];
    const syntaxList = child.getParentSyntaxListOrThrow();
    const isRemovingFirstChild = childrenToRemove[0] === syntaxList.getFirstChild();
    addNextCommaIfAble();
    addPreviousCommaIfAble();
    removeChildren({
        children: childrenToRemove,
        removePrecedingSpaces: !isRemovingFirstChild || syntaxList.getChildren().length === childrenToRemove.length && childrenToRemove[0].isFirstNodeOnLine(),
        removeFollowingSpaces: isRemovingFirstChild,
        removePrecedingNewLines: !isRemovingFirstChild,
        removeFollowingNewLines: isRemovingFirstChild
    });
    function addNextCommaIfAble() {
        const commaToken = child.getNextSiblingIfKind(typescript_1.SyntaxKind.CommaToken);
        if (commaToken != null)
            childrenToRemove.push(commaToken);
    }
    function addPreviousCommaIfAble() {
        if (syntaxList.getLastChild() !== childrenToRemove[childrenToRemove.length - 1])
            return;
        const precedingComma = child.getPreviousSiblingIfKind(typescript_1.SyntaxKind.CommaToken);
        if (precedingComma != null)
            childrenToRemove.unshift(precedingComma);
    }
}
exports.removeCommaSeparatedChild = removeCommaSeparatedChild;
function removeOverloadableStatementedNodeChild(node) {
    if (node.isOverload())
        removeChildren({ children: [node], removeFollowingSpaces: true, removeFollowingNewLines: true });
    else
        removeStatementedNodeChildren([...node.getOverloads(), node]);
}
exports.removeOverloadableStatementedNodeChild = removeOverloadableStatementedNodeChild;
function removeStatementedNodeChild(node) {
    removeStatementedNodeChildren([node]);
}
exports.removeStatementedNodeChild = removeStatementedNodeChild;
function removeStatementedNodeChildren(nodes) {
    removeChildrenWithFormatting({
        getSiblingFormatting: formatting_1.getStatementedNodeChildFormatting,
        children: nodes
    });
}
exports.removeStatementedNodeChildren = removeStatementedNodeChildren;
function removeClausedNodeChild(node) {
    removeClausedNodeChildren([node]);
}
exports.removeClausedNodeChild = removeClausedNodeChild;
function removeClausedNodeChildren(nodes) {
    removeChildrenWithFormatting({
        getSiblingFormatting: formatting_1.getClausedNodeChildFormatting,
        children: nodes
    });
}
exports.removeClausedNodeChildren = removeClausedNodeChildren;
function unwrapNode(node) {
    doManipulation_1.doManipulation(node._sourceFile, new textManipulators_1.UnwrapTextManipulator(node), new nodeHandlers_1.NodeHandlerFactory().getForUnwrappingNode(node));
}
exports.unwrapNode = unwrapNode;
