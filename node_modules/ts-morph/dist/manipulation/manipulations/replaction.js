"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const nodeHandlers_1 = require("../nodeHandlers");
const textManipulators_1 = require("../textManipulators");
const doManipulation_1 = require("./doManipulation");
/**
 * Replaces text in a source file. Will forget any changed nodes.
 */
function replaceNodeText(opts) {
    doManipulation_1.doManipulation(opts.sourceFile, new textManipulators_1.InsertionTextManipulator({
        insertPos: opts.start,
        newText: opts.newText,
        replacingLength: opts.replacingLength
    }), new nodeHandlers_1.NodeHandlerFactory().getForForgetChanged(opts.sourceFile._context.compilerFactory));
}
exports.replaceNodeText = replaceNodeText;
/**
 * Replaces the text in a source file and assumes only the nodes will shift (no tree structure should change).
 *
 * This is very useful when making formatting changes that won't change the AST structure.
 */
function replaceSourceFileTextForFormatting(opts) {
    replaceSourceFileTextStraight(opts);
}
exports.replaceSourceFileTextForFormatting = replaceSourceFileTextForFormatting;
/**
 * Replaces the source file text and assumes the wrapped nodes will be the same (no tree structure should change).
 */
function replaceSourceFileTextStraight(opts) {
    const { sourceFile, newText } = opts;
    doManipulation_1.doManipulation(sourceFile, new textManipulators_1.FullReplacementTextManipulator(newText), new nodeHandlers_1.NodeHandlerFactory().getForStraightReplacement(sourceFile._context.compilerFactory));
}
exports.replaceSourceFileTextStraight = replaceSourceFileTextStraight;
/**
 * Replaces the text in a source file based on rename locations.
 */
function replaceSourceFileTextForRename(opts) {
    const { sourceFile, renameLocations, newName } = opts;
    const nodeHandlerFactory = new nodeHandlers_1.NodeHandlerFactory();
    doManipulation_1.doManipulation(sourceFile, new textManipulators_1.RenameLocationTextManipulator(renameLocations, newName), nodeHandlerFactory.getForTryOrForget(nodeHandlerFactory.getForForgetChanged(sourceFile._context.compilerFactory)));
}
exports.replaceSourceFileTextForRename = replaceSourceFileTextForRename;
/**
 * Replaces a node text while possibly creating new child nodes.
 */
function replaceTextPossiblyCreatingChildNodes(opts) {
    const { replacePos, replacingLength, newText, parent } = opts;
    doManipulation_1.doManipulation(parent._sourceFile, new textManipulators_1.InsertionTextManipulator({
        insertPos: replacePos,
        replacingLength,
        newText
    }), new nodeHandlers_1.NodeHandlerFactory().getForParentRange({
        parent,
        start: replacePos,
        end: replacePos + newText.length
    }));
}
exports.replaceTextPossiblyCreatingChildNodes = replaceTextPossiblyCreatingChildNodes;
/**
 * Replaces a source file for a file path move.
 */
function replaceSourceFileForFilePathMove(opts) {
    const { sourceFile, newFilePath } = opts;
    doManipulation_1.doManipulation(sourceFile, new textManipulators_1.UnchangedTextManipulator(), new nodeHandlers_1.NodeHandlerFactory().getForStraightReplacement(sourceFile._context.compilerFactory), newFilePath);
}
exports.replaceSourceFileForFilePathMove = replaceSourceFileForFilePathMove;
/**
 * Replaces the source file and all its descendant nodes in the cache.
 * @param sourceFile - Source file.
 */
function replaceSourceFileForCacheUpdate(sourceFile) {
    replaceSourceFileForFilePathMove({ sourceFile, newFilePath: sourceFile.getFilePath() });
}
exports.replaceSourceFileForCacheUpdate = replaceSourceFileForCacheUpdate;
