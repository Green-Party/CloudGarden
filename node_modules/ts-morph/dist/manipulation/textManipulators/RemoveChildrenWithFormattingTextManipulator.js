"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const formatting_1 = require("../formatting");
const textChecks_1 = require("../textChecks");
const textSeek_1 = require("../textSeek");
const getSpacingBetweenNodes_1 = require("./getSpacingBetweenNodes");
const getTextForError_1 = require("./getTextForError");
class RemoveChildrenWithFormattingTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const { children, getSiblingFormatting } = this.opts;
        const parent = children[0].getParentOrThrow();
        const sourceFile = parent.getSourceFile();
        const fullText = sourceFile.getFullText();
        const newLineKind = sourceFile._context.manipulationSettings.getNewLineKindAsString();
        const previousSibling = children[0].getPreviousSibling();
        const nextSibling = children[children.length - 1].getNextSibling();
        const removalPos = getRemovalPos();
        this.removalPos = removalPos;
        // console.log(JSON.stringify(fullText.substring(0, removalPos)));
        // console.log(JSON.stringify(fullText.substring(getRemovalEnd())));
        return getPrefix() + getSpacing() + getSuffix();
        function getPrefix() {
            return fullText.substring(0, removalPos);
        }
        function getSpacing() {
            return getSpacingBetweenNodes_1.getSpacingBetweenNodes({
                parent,
                previousSibling,
                nextSibling,
                newLineKind,
                getSiblingFormatting
            });
        }
        function getSuffix() {
            return fullText.substring(getRemovalEnd());
        }
        function getRemovalPos() {
            if (previousSibling != null) {
                const trailingEnd = previousSibling.getTrailingTriviaEnd();
                return textChecks_1.isNewLineAtPos(fullText, trailingEnd) ? trailingEnd : previousSibling.getEnd();
            }
            const firstPos = textSeek_1.getPreviousNonWhitespacePos(fullText, children[0].getPos());
            if (parent.getPos() === firstPos)
                return children[0].getNonWhitespaceStart(); // do not shift the parent
            return children[0].isFirstNodeOnLine() ? firstPos : children[0].getNonWhitespaceStart();
        }
        function getRemovalEnd() {
            if (previousSibling != null && nextSibling != null) {
                const nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
                if (nextSiblingFormatting === formatting_1.FormattingKind.Blankline || nextSiblingFormatting === formatting_1.FormattingKind.Newline)
                    return textSeek_1.getPosAtStartOfLineOrNonWhitespace(fullText, nextSibling.getNonWhitespaceStart());
                return nextSibling.getNonWhitespaceStart();
            }
            if (parent.getEnd() === children[children.length - 1].getEnd())
                return children[children.length - 1].getEnd(); // do not shift the parent
            const triviaEnd = children[children.length - 1].getTrailingTriviaEnd();
            if (textChecks_1.isNewLineAtPos(fullText, triviaEnd)) {
                if (previousSibling == null && children[0].getPos() === 0)
                    return textSeek_1.getPosAtNextNonBlankLine(fullText, triviaEnd);
                return textSeek_1.getPosAtEndOfPreviousLine(fullText, textSeek_1.getPosAtNextNonBlankLine(fullText, triviaEnd));
            }
            if (previousSibling == null)
                return triviaEnd;
            else
                return children[children.length - 1].getEnd();
        }
    }
    getTextForError(newText) {
        return getTextForError_1.getTextForError(newText, this.removalPos);
    }
}
exports.RemoveChildrenWithFormattingTextManipulator = RemoveChildrenWithFormattingTextManipulator;
