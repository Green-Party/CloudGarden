"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* barrel:ignore */
const typescript_1 = require("../typescript");
const utils_1 = require("../utils");
const errors = require("../errors");
class DocumentRegistry {
    constructor(fileSystemWrapper) {
        this.fileSystemWrapper = fileSystemWrapper;
        this.sourceFileCacheByFilePath = new utils_1.KeyValueCache();
    }
    removeSourceFile(fileName) {
        this.sourceFileCacheByFilePath.removeByKey(fileName);
    }
    createOrUpdateSourceFile(fileName, compilationSettings, scriptSnapshot) {
        let sourceFile = this.sourceFileCacheByFilePath.get(fileName);
        if (sourceFile == null)
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, DocumentRegistry.initialVersion);
        else
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, this.getNextSourceFileVersion(sourceFile));
        return sourceFile;
    }
    acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        let sourceFile = this.sourceFileCacheByFilePath.get(fileName);
        if (sourceFile == null || this.getSourceFileVersion(sourceFile) !== version)
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, version);
        return sourceFile;
    }
    acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        // ignore the key because we only ever keep track of one key
        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    }
    updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        // the compiler will call this even when it doesn't need to update for some reason
        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    }
    updateDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        // ignore the key because we only ever keep track of one key
        return this.updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    }
    getKeyForCompilationSettings(settings) {
        return "defaultKey";
    }
    releaseDocument(fileName, compilationSettings) {
        // ignore, handled by removeSourceFile
    }
    releaseDocumentWithKey(path, key) {
        // ignore, handled by removeSourceFile
    }
    reportStats() {
        throw new errors.NotImplementedError();
    }
    getSourceFileVersion(sourceFile) {
        return sourceFile.version || "0";
    }
    getNextSourceFileVersion(sourceFile) {
        const currentVersion = parseInt(this.getSourceFileVersion(sourceFile), 10) || 0;
        return (currentVersion + 1).toString();
    }
    updateSourceFile(fileName, compilationSettings, scriptSnapshot, version) {
        fileName = this.fileSystemWrapper.getStandardizedAbsolutePath(fileName);
        const newSourceFile = this.createCompilerSourceFile(fileName, scriptSnapshot, compilationSettings, version);
        this.sourceFileCacheByFilePath.set(fileName, newSourceFile);
        return newSourceFile;
    }
    createCompilerSourceFile(fileName, scriptSnapshot, compilationSettings, version) {
        const scriptTarget = compilationSettings.target || typescript_1.ScriptTarget.Latest;
        return typescript_1.ts.createLanguageServiceSourceFile(fileName, scriptSnapshot, scriptTarget, version, true, /* scriptKind */ undefined);
    }
}
DocumentRegistry.initialVersion = "0";
exports.DocumentRegistry = DocumentRegistry;
