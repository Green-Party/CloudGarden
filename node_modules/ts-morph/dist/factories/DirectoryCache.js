"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Directory_1 = require("../fileSystem/Directory");
const utils_1 = require("../utils");
/**
 * Cache for the directories.
 * @internal
 */
class DirectoryCache {
    constructor(context) {
        this.context = context;
        this.directoriesByPath = new utils_1.KeyValueCache();
        this.sourceFilesByDirPath = new utils_1.KeyValueCache();
        this.directoriesByDirPath = new utils_1.KeyValueCache();
        this.orphanDirs = new utils_1.KeyValueCache();
    }
    has(dirPath) {
        return this.directoriesByPath.has(dirPath);
    }
    get(dirPath) {
        if (!this.directoriesByPath.has(dirPath)) {
            for (const orphanDir of this.orphanDirs.getValues()) {
                if (utils_1.FileUtils.pathStartsWith(orphanDir.getPath(), dirPath))
                    return this.createOrAddIfExists(dirPath);
            }
            return undefined;
        }
        return this.directoriesByPath.get(dirPath);
    }
    getOrphans() {
        return this.orphanDirs.getValuesAsArray();
    }
    getAll() {
        return this.directoriesByPath.getValuesAsArray();
    }
    *getAllByDepth() {
        const dirLevels = new utils_1.KeyValueCache();
        let depth = 0;
        this.getOrphans().forEach(addToDirLevels);
        depth = Math.min(...Array.from(dirLevels.getKeys()));
        while (dirLevels.getSize() > 0) {
            for (const dir of dirLevels.get(depth) || []) {
                yield dir;
                dir.getDirectories().forEach(addToDirLevels);
            }
            dirLevels.removeByKey(depth);
            depth++;
        }
        function addToDirLevels(dir) {
            const dirDepth = dir._getDepth();
            /* istanbul ignore if */
            if (depth > dirDepth)
                throw new Error(`For some reason a subdirectory had a lower depth than the parent directory: ${dir.getPath()}`);
            const dirs = dirLevels.getOrCreate(dirDepth, () => []);
            dirs.push(dir);
        }
    }
    remove(dirPath) {
        this.removeFromDirectoriesByDirPath(dirPath);
        this.directoriesByPath.removeByKey(dirPath);
        this.orphanDirs.removeByKey(dirPath);
    }
    getChildDirectoriesOfDirectory(dirPath) {
        const directories = this.directoriesByDirPath.get(dirPath);
        if (directories == null)
            return [];
        return directories.getArrayCopy();
    }
    getChildSourceFilesOfDirectory(dirPath) {
        const sourceFiles = this.sourceFilesByDirPath.get(dirPath);
        if (sourceFiles == null)
            return [];
        return sourceFiles.getArrayCopy();
    }
    addSourceFile(sourceFile) {
        const dirPath = sourceFile.getDirectoryPath();
        this.createOrAddIfExists(dirPath);
        const sourceFiles = this.sourceFilesByDirPath.getOrCreate(dirPath, () => new utils_1.SortedKeyValueArray(item => item.getBaseName(), utils_1.LocaleStringComparer.instance));
        sourceFiles.set(sourceFile);
    }
    removeSourceFile(filePath) {
        const dirPath = utils_1.FileUtils.getDirPath(filePath);
        const sourceFiles = this.sourceFilesByDirPath.get(dirPath);
        if (sourceFiles == null)
            return;
        sourceFiles.removeByKey(utils_1.FileUtils.getBaseName(filePath));
        // clean up
        if (!sourceFiles.hasItems())
            this.sourceFilesByDirPath.removeByKey(dirPath);
    }
    createOrAddIfExists(dirPath) {
        if (this.has(dirPath))
            return this.get(dirPath);
        this.fillParentsOfDirPath(dirPath);
        return this.createDirectory(dirPath);
    }
    createDirectory(path) {
        const newDirectory = new Directory_1.Directory(this.context, path);
        this.addDirectory(newDirectory);
        return newDirectory;
    }
    addDirectory(directory) {
        const path = directory.getPath();
        const parentDirPath = utils_1.FileUtils.getDirPath(path);
        const isRootDir = parentDirPath === path;
        // remove any orphans that have a loaded parent
        for (const orphanDir of this.orphanDirs.getValues()) {
            const orphanDirPath = orphanDir.getPath();
            const orphanDirParentPath = utils_1.FileUtils.getDirPath(orphanDirPath);
            const isOrphanRootDir = orphanDirParentPath === orphanDirPath;
            if (!isOrphanRootDir && orphanDirParentPath === path)
                this.orphanDirs.removeByKey(orphanDirPath);
        }
        if (!isRootDir)
            this.addToDirectoriesByDirPath(directory);
        if (!this.has(parentDirPath))
            this.orphanDirs.set(path, directory);
        this.directoriesByPath.set(path, directory);
        if (!this.context.fileSystemWrapper.directoryExistsSync(path))
            this.context.fileSystemWrapper.queueMkdir(path);
        for (const orphanDir of this.orphanDirs.getValues()) {
            if (directory.isAncestorOf(orphanDir))
                this.fillParentsOfDirPath(orphanDir.getPath());
        }
    }
    addToDirectoriesByDirPath(directory) {
        if (utils_1.FileUtils.isRootDirPath(directory.getPath()))
            return;
        const parentDirPath = utils_1.FileUtils.getDirPath(directory.getPath());
        const directories = this.directoriesByDirPath.getOrCreate(parentDirPath, () => new utils_1.SortedKeyValueArray(item => item.getBaseName(), utils_1.LocaleStringComparer.instance));
        directories.set(directory);
    }
    removeFromDirectoriesByDirPath(dirPath) {
        if (utils_1.FileUtils.isRootDirPath(dirPath))
            return;
        const parentDirPath = utils_1.FileUtils.getDirPath(dirPath);
        const directories = this.directoriesByDirPath.get(parentDirPath);
        if (directories == null)
            return;
        directories.removeByKey(utils_1.FileUtils.getBaseName(dirPath));
        // clean up
        if (!directories.hasItems())
            this.directoriesByDirPath.removeByKey(parentDirPath);
    }
    fillParentsOfDirPath(dirPath) {
        const passedDirPaths = [];
        let parentDir = utils_1.FileUtils.getDirPath(dirPath);
        while (dirPath !== parentDir) {
            dirPath = parentDir;
            parentDir = utils_1.FileUtils.getDirPath(dirPath);
            if (this.directoriesByPath.has(dirPath)) {
                for (const currentDirPath of passedDirPaths)
                    this.createDirectory(currentDirPath);
                break;
            }
            passedDirPaths.unshift(dirPath);
        }
    }
}
exports.DirectoryCache = DirectoryCache;
