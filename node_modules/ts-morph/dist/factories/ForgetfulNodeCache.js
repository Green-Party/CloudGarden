"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../errors");
const typescript_1 = require("../typescript");
const utils_1 = require("../utils");
/**
 * Extension of KeyValueCache that allows for "forget points."
 */
class ForgetfulNodeCache extends utils_1.KeyValueCache {
    constructor() {
        super(...arguments);
        this.forgetStack = [];
    }
    getOrCreate(key, createFunc) {
        return super.getOrCreate(key, () => {
            const node = createFunc();
            if (this.forgetStack.length > 0)
                this.forgetStack[this.forgetStack.length - 1].add(node);
            return node;
        });
    }
    setForgetPoint() {
        this.forgetStack.push(new Set());
    }
    forgetLastPoint() {
        const nodes = this.forgetStack.pop();
        if (nodes != null)
            this.forgetNodes(nodes.values());
    }
    rememberNode(node) {
        if (node.wasForgotten())
            throw new errors.InvalidOperationError("Cannot remember a node that was removed or forgotten.");
        let wasInForgetStack = false;
        for (const stackItem of this.forgetStack) {
            if (stackItem.delete(node)) {
                wasInForgetStack = true;
                break;
            }
        }
        if (wasInForgetStack)
            this.rememberParentOfNode(node);
        return wasInForgetStack;
    }
    rememberParentOfNode(node) {
        const parent = node.getParentSyntaxList() || node.getParent();
        if (parent != null)
            this.rememberNode(parent);
    }
    forgetNodes(nodes) {
        for (const node of nodes) {
            if (node.wasForgotten() || node.getKind() === typescript_1.SyntaxKind.SourceFile)
                continue;
            node._forgetOnlyThis();
        }
    }
}
exports.ForgetfulNodeCache = ForgetfulNodeCache;
