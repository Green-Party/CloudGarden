"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
/**
 * Holds information about whether source files or directories are in the project.
 *
 * todo: Move this to a different folder.
 */
class InProjectCoordinator {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
        this.notInProjectFiles = new Set();
        compilerFactory.onSourceFileRemoved(sourceFile => {
            this.notInProjectFiles.delete(sourceFile);
        });
    }
    /** Sets the source file as not being in the project. */
    setSourceFileNotInProject(sourceFile) {
        this.notInProjectFiles.add(sourceFile);
        sourceFile._inProject = false;
    }
    /** Marks the specified source file being included in the project. */
    markSourceFileAsInProject(sourceFile) {
        if (this.isSourceFileInProject(sourceFile))
            return;
        this._internalMarkSourceFileAsInProject(sourceFile);
        this.notInProjectFiles.delete(sourceFile);
    }
    /**
     * Marks source files not in a not in project node_modules folder as being in the project.
     * @returns Source files that were marked as being in the project.
     */
    markSourceFilesAsInProjectForResolution() {
        const nodeModulesSearchName = "/node_modules/";
        const compilerFactory = this.compilerFactory;
        const changedSourceFiles = [];
        const unchangedSourceFiles = [];
        for (const sourceFile of [...this.notInProjectFiles.values()]) {
            if (shouldMarkInProject(sourceFile)) {
                this._internalMarkSourceFileAsInProject(sourceFile);
                this.notInProjectFiles.delete(sourceFile);
                changedSourceFiles.push(sourceFile);
            }
            else {
                unchangedSourceFiles.push(sourceFile);
            }
        }
        return { changedSourceFiles, unchangedSourceFiles };
        function shouldMarkInProject(sourceFile) {
            // check if there's a node_modules directory (use the closest one)
            const filePath = sourceFile.getFilePath();
            const index = filePath.toLowerCase().lastIndexOf(nodeModulesSearchName);
            if (index === -1)
                return true;
            // see if the node_modules directory is in the project
            const nodeModulesPath = filePath.substring(0, index + nodeModulesSearchName.length - 1); // remove last slash
            const nodeModulesDir = compilerFactory.getDirectoryFromCacheOnlyIfInCache(nodeModulesPath);
            if (nodeModulesDir != null && nodeModulesDir._isInProject())
                return true;
            // see if there's a directory between this and the node_modules directory that's in the project
            let directory = sourceFile.getDirectory();
            while (directory != null && directory.getPath() !== nodeModulesPath) {
                if (directory._isInProject())
                    return true;
                directory = compilerFactory.getDirectoryFromCacheOnlyIfInCache(utils_1.FileUtils.getDirPath(directory.getPath()));
            }
            // otherwise, don't mark it as in the project
            return false;
        }
    }
    _internalMarkSourceFileAsInProject(sourceFile) {
        sourceFile._inProject = true;
        this.markDirectoryAsInProject(sourceFile.getDirectory());
    }
    /** Checks if the specified source file is in the project. */
    isSourceFileInProject(sourceFile) {
        return sourceFile._inProject === true;
    }
    /** Sets the directory and files as not being in the project for testing. */
    setDirectoryAndFilesAsNotInProjectForTesting(directory) {
        for (const subDir of directory.getDirectories())
            this.setDirectoryAndFilesAsNotInProjectForTesting(subDir);
        for (const file of directory.getSourceFiles()) {
            delete file._inProject;
            this.notInProjectFiles.add(file);
        }
        delete directory._inProject;
    }
    /** Marks the specified directory as being in the project. */
    markDirectoryAsInProject(directory) {
        if (this.isDirectoryInProject(directory))
            return;
        const inProjectCoordinator = this;
        const compilerFactory = this.compilerFactory;
        directory._inProject = true;
        markAncestorDirs(directory);
        function markAncestorDirs(dir) {
            const ancestorDirs = Array.from(getAncestorsUpToOneInProject(dir));
            // only mark the ancestor directories as being in the project if the top one is in the project
            const topAncestor = ancestorDirs[ancestorDirs.length - 1];
            if (topAncestor == null || !inProjectCoordinator.isDirectoryInProject(topAncestor))
                return;
            for (const ancestorDir of ancestorDirs)
                ancestorDir._inProject = true;
        }
        function* getAncestorsUpToOneInProject(dir) {
            if (utils_1.FileUtils.isRootDirPath(dir.getPath()))
                return;
            const parentDirPath = utils_1.FileUtils.getDirPath(dir.getPath());
            const parentDir = compilerFactory.getDirectoryFromCacheOnlyIfInCache(parentDirPath);
            if (parentDir == null)
                return;
            yield parentDir;
            if (!inProjectCoordinator.isDirectoryInProject(parentDir))
                yield* getAncestorsUpToOneInProject(parentDir);
        }
    }
    /** Checks if the specified directory is in the project. */
    isDirectoryInProject(directory) {
        return directory._inProject === true;
    }
}
exports.InProjectCoordinator = InProjectCoordinator;
