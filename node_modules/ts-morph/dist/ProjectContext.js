"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codeBlockWriter_1 = require("./codeBlockWriter");
const compiler_1 = require("./compiler");
const errors = require("./errors");
const factories_1 = require("./factories");
const fileSystem_1 = require("./fileSystem");
const options_1 = require("./options");
const typescript_1 = require("./typescript");
const utils_1 = require("./utils");
const createWrappedNode_1 = require("./utils/compiler/createWrappedNode");
/**
 * Context for a project instance.
 * @internal
 */
class ProjectContext {
    constructor(project, fileSystemWrapper, compilerOptions, opts) {
        this._compilerOptions = new options_1.CompilerOptionsContainer();
        this.logger = new utils_1.ConsoleLogger();
        this.manipulationSettings = new options_1.ManipulationSettingsContainer();
        this._project = project;
        this.fileSystemWrapper = fileSystemWrapper;
        this._compilerOptions.set(compilerOptions);
        this.compilerFactory = new factories_1.CompilerFactory(this);
        this.inProjectCoordinator = new factories_1.InProjectCoordinator(this.compilerFactory);
        this.structurePrinterFactory = new factories_1.StructurePrinterFactory(() => this.manipulationSettings.getFormatCodeSettings());
        this.lazyReferenceCoordinator = new utils_1.LazyReferenceCoordinator(this.compilerFactory);
        this.directoryCoordinator = new fileSystem_1.DirectoryCoordinator(this.compilerFactory, fileSystemWrapper);
        this._languageService = opts.createLanguageService ? new compiler_1.LanguageService(this, { resolutionHost: opts.resolutionHost }) : undefined;
        if (opts.typeChecker != null) {
            errors.throwIfTrue(opts.createLanguageService, "Cannot specify a type checker and create a language service.");
            this._customTypeChecker = new compiler_1.TypeChecker(this);
            this._customTypeChecker._reset(() => opts.typeChecker);
        }
    }
    get project() {
        if (this._project == null)
            throw new errors.InvalidOperationError("This operation is not permitted in this context.");
        return this._project;
    }
    /** Gets the compiler options. */
    get compilerOptions() {
        return this._compilerOptions;
    }
    /** Gets the language service. Throws an exception if it doesn't exist. */
    get languageService() {
        if (this._languageService == null)
            throw this.getToolRequiredError("language service");
        return this._languageService;
    }
    /**
     * Gets the program.
     */
    get program() {
        if (this._languageService == null)
            throw this.getToolRequiredError("program");
        return this.languageService.getProgram();
    }
    /**
     * Gets the type checker.
     */
    get typeChecker() {
        if (this._customTypeChecker != null)
            return this._customTypeChecker;
        if (this._languageService == null)
            throw this.getToolRequiredError("type checker");
        return this.program.getTypeChecker();
    }
    /**
     * Gets if this object has a language service.
     */
    hasLanguageService() {
        return this._languageService != null;
    }
    /**
     * Gets the encoding.
     */
    getEncoding() {
        return this.compilerOptions.get().charset || "utf-8";
    }
    /**
     * Helper for getting the format code settings.
     */
    getFormatCodeSettings() {
        return this.manipulationSettings.getFormatCodeSettings();
    }
    /**
     * Helper for getting the user preferences.
     */
    getUserPreferences() {
        return this.manipulationSettings.getUserPreferences();
    }
    /**
     * Resets the program.
     */
    resetProgram() {
        this.languageService._resetProgram();
    }
    /**
     * Creates a code block writer.
     */
    createWriter() {
        const indentationText = this.manipulationSettings.getIndentationText();
        return new codeBlockWriter_1.CodeBlockWriter({
            newLine: this.manipulationSettings.getNewLineKindAsString(),
            indentNumberOfSpaces: indentationText === options_1.IndentationText.Tab ? undefined : indentationText.length,
            useTabs: indentationText === options_1.IndentationText.Tab,
            useSingleQuote: this.manipulationSettings.getQuoteKind() === compiler_1.QuoteKind.Single
        });
    }
    /**
     * Gets the pre-emit diagnostics.
     * @param sourceFile - Optional source file to filter the results by.
     */
    getPreEmitDiagnostics(sourceFile) {
        const compilerDiagnostics = typescript_1.ts.getPreEmitDiagnostics(this.program.compilerObject, sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this.compilerFactory.getDiagnostic(d));
    }
    getToolRequiredError(name) {
        return new errors.InvalidOperationError(`A ${name} is required for this operation. ` +
            "This might occur when manipulating or getting type information from a node that was not added " +
            `to a Project object and created via ${"createWrappedNode"}. ` +
            `Please submit a bug report if you don't believe a ${name} should be required for this operation.`);
    }
}
exports.ProjectContext = ProjectContext;
