"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const structures_1 = require("../../../structures");
const utils_1 = require("../../../utils");
const base_1 = require("../base");
const callBaseSet_1 = require("../callBaseSet");
const module_1 = require("../module");
const statement_1 = require("../statement");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const base_2 = require("./base");
const common_1 = require("../common");
exports.ClassDeclarationBase = module_1.NamespaceChildableNode(base_1.AmbientableNode(base_1.ExportableNode(base_2.ClassLikeDeclarationBase(statement_1.Statement))));
class ClassDeclaration extends exports.ClassDeclarationBase {
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        callBaseSet_1.callBaseSet(exports.ClassDeclarationBase.prototype, this, structure);
        if (structure.extends != null)
            this.setExtends(structure.extends);
        else if (structure.hasOwnProperty("extends"))
            this.removeExtends();
        if (structure.ctors != null) {
            this.getConstructors().forEach(c => c.remove());
            this.addConstructors(structure.ctors);
        }
        if (structure.properties != null) {
            this.getProperties().forEach(p => p.remove());
            this.addProperties(structure.properties);
        }
        if (structure.getAccessors != null) {
            this.getGetAccessors().forEach(a => a.remove());
            this.addGetAccessors(structure.getAccessors);
        }
        if (structure.setAccessors != null) {
            this.getSetAccessors().forEach(a => a.remove());
            this.addSetAccessors(structure.setAccessors);
        }
        if (structure.methods != null) {
            this.getMethods().forEach(m => m.remove());
            this.addMethods(structure.methods);
        }
        return this;
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        const getExtends = this.getExtends();
        const isAmbient = this.isAmbient();
        return callBaseGetStructure_1.callBaseGetStructure(exports.ClassDeclarationBase.prototype, this, {
            kind: structures_1.StructureKind.Class,
            ctors: this.getConstructors().filter(ctor => isAmbient || !ctor.isOverload()).map(ctor => ctor.getStructure()),
            methods: this.getMethods().filter(method => isAmbient || !method.isOverload()).map(method => method.getStructure()),
            properties: this.getProperties().map(property => property.getStructure()),
            extends: getExtends ? getExtends.getText() : undefined,
            getAccessors: this.getGetAccessors().map(getAccessor => getAccessor.getStructure()),
            setAccessors: this.getSetAccessors().map(accessor => accessor.getStructure())
        });
    }
    /**
     * Extracts an interface declaration structure from the class.
     * @param name - Name of the interface. Falls back to the same name as the class and then the filepath's base name.
     */
    extractInterface(name) {
        const { constructors, properties, methods, accessors } = getExtractedClassDetails(this, false);
        const parameterProperties = utils_1.ArrayUtils.flatten(constructors.map(c => c.getParameters().filter(p => p.isParameterProperty())))
            .filter(p => p.getName() != null && p.getScope() === common_1.Scope.Public);
        return {
            kind: structures_1.StructureKind.Interface,
            name: getDefaultExtractedName(name, this),
            docs: this.getJsDocs().map(d => d.getStructure()),
            typeParameters: this.getTypeParameters().map(p => p.getStructure()),
            properties: [
                ...parameterProperties.map(p => {
                    const jsDocComment = utils_1.ArrayUtils.flatten(p.getParentOrThrow().getJsDocs().map(j => j.getTags()))
                        .filter(utils_1.TypeGuards.isJSDocParameterTag)
                        .filter(t => t.getTagName() === "param" && t.getName() === p.getName() && t.getComment() != null)
                        .map(t => t.getComment().trim())[0];
                    return {
                        kind: structures_1.StructureKind.PropertySignature,
                        docs: jsDocComment == null ? [] : [{ kind: structures_1.StructureKind.JSDoc, description: jsDocComment }],
                        name: p.getName(),
                        type: p.getType().getText(p),
                        hasQuestionToken: p.hasQuestionToken(),
                        isReadonly: p.isReadonly()
                    };
                }),
                ...properties.map(getExtractedInterfacePropertyStructure),
                ...accessors.map(getExtractedInterfaceAccessorStructure)
            ],
            methods: methods.map(getExtractedInterfaceMethodStructure)
        };
    }
    /**
     * Extracts an interface declaration structure from the static part of the class.
     * @param name - Name of the interface.
     */
    extractStaticInterface(name) {
        const { constructors, properties, methods, accessors } = getExtractedClassDetails(this, true);
        const instanceName = getDefaultExtractedName(undefined, this);
        return {
            kind: structures_1.StructureKind.Interface,
            name,
            properties: [
                ...properties.map(getExtractedInterfacePropertyStructure),
                ...accessors.map(getExtractedInterfaceAccessorStructure)
            ],
            methods: methods.map(getExtractedInterfaceMethodStructure),
            constructSignatures: constructors.map(c => ({
                kind: structures_1.StructureKind.ConstructSignature,
                docs: c.getJsDocs().map(d => d.getStructure()),
                parameters: c.getParameters().map(p => (Object.assign({}, getExtractedInterfaceParameterStructure(p), { scope: undefined, isReadonly: false }))),
                returnType: instanceName
            }))
        };
    }
}
exports.ClassDeclaration = ClassDeclaration;
function getExtractedClassDetails(classDec, isStatic) {
    const constructors = utils_1.ArrayUtils.flatten(classDec.getConstructors().map(c => c.getOverloads().length > 0 ? c.getOverloads() : [c]));
    const properties = classDec.getProperties().filter(p => p.isStatic() === isStatic && p.getScope() === common_1.Scope.Public);
    const methods = utils_1.ArrayUtils.flatten(classDec.getMethods()
        .filter(p => p.isStatic() === isStatic && p.getScope() === common_1.Scope.Public)
        .map(m => m.getOverloads().length > 0 ? m.getOverloads() : [m]));
    return { constructors, properties, methods, accessors: getAccessors() };
    function getAccessors() {
        const result = new utils_1.KeyValueCache();
        for (const accessor of [...classDec.getGetAccessors(), ...classDec.getSetAccessors()]) {
            if (accessor.isStatic() === isStatic && accessor.getScope() === common_1.Scope.Public)
                result.getOrCreate(accessor.getName(), () => []).push(accessor);
        }
        return result.getValuesAsArray();
    }
}
function getDefaultExtractedName(name, classDec) {
    name = utils_1.StringUtils.isNullOrWhitespace(name) ? undefined : name;
    return name || classDec.getName() || classDec.getSourceFile().getBaseNameWithoutExtension().replace(/[^a-zA-Z0-9_$]/g, "");
}
function getExtractedInterfacePropertyStructure(prop) {
    return {
        kind: structures_1.StructureKind.PropertySignature,
        docs: prop.getJsDocs().map(d => d.getStructure()),
        name: prop.getName(),
        type: prop.getType().getText(prop),
        hasQuestionToken: prop.hasQuestionToken(),
        isReadonly: prop.isReadonly()
    };
}
function getExtractedInterfaceAccessorStructure(getAndSet) {
    return {
        kind: structures_1.StructureKind.PropertySignature,
        docs: getAndSet[0].getJsDocs().map(d => d.getStructure()),
        name: getAndSet[0].getName(),
        type: getAndSet[0].getType().getText(getAndSet[0]),
        hasQuestionToken: false,
        isReadonly: getAndSet.every(utils_1.TypeGuards.isGetAccessorDeclaration)
    };
}
function getExtractedInterfaceMethodStructure(method) {
    return {
        kind: structures_1.StructureKind.MethodSignature,
        docs: method.getJsDocs().map(d => d.getStructure()),
        name: method.getName(),
        hasQuestionToken: method.hasQuestionToken(),
        returnType: method.getReturnType().getText(method),
        parameters: method.getParameters().map(getExtractedInterfaceParameterStructure),
        typeParameters: method.getTypeParameters().map(p => p.getStructure())
    };
}
function getExtractedInterfaceParameterStructure(param) {
    return Object.assign({}, param.getStructure(), { decorators: [] });
}
