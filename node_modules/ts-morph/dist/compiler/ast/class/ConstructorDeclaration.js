"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getStructureFuncs = require("../../../manipulation/helpers/getStructureFunctions");
const structures_1 = require("../../../structures");
const typescript_1 = require("../../../typescript");
const base_1 = require("../base");
const callBaseSet_1 = require("../callBaseSet");
const function_1 = require("../function");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const ClassElement_1 = require("./ClassElement");
exports.ConstructorDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(function_1.OverloadableNode(base_1.ScopedNode(function_1.FunctionLikeDeclaration(base_1.BodyableNode(ClassElement_1.ClassElement))))));
exports.ConstructorDeclarationOverloadBase = base_1.TypeParameteredNode(base_1.JSDocableNode(base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.ScopedNode(base_1.ModifierableNode(base_1.SignaturedDeclaration(ClassElement_1.ClassElement)))))));
class ConstructorDeclaration extends exports.ConstructorDeclarationBase {
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        callBaseSet_1.callBaseSet(exports.ConstructorDeclarationBase.prototype, this, structure);
        if (structure.overloads != null) {
            this.getOverloads().forEach(o => o.remove());
            this.addOverloads(structure.overloads);
        }
        return this;
    }
    /**
     * Add a constructor overload.
     * @param structure - Structure to add.
     */
    addOverload(structure) {
        return this.addOverloads([structure])[0];
    }
    /**
     * Add constructor overloads.
     * @param structures - Structures to add.
     */
    addOverloads(structures) {
        return this.insertOverloads(this.getOverloads().length, structures);
    }
    /**
     * Inserts a constructor overload.
     * @param index - Child index to insert at.
     * @param structure - Structures to insert.
     */
    insertOverload(index, structure) {
        return this.insertOverloads(index, [structure])[0];
    }
    /**
     * Inserts constructor overloads.
     * @param index - Child index to insert at.
     * @param structures - Structures to insert.
     */
    insertOverloads(index, structures) {
        const childCodes = structures.map(structure => `constructor();`);
        return function_1.insertOverloads({
            node: this,
            index,
            structures,
            childCodes,
            getThisStructure: getStructureFuncs.fromConstructorDeclarationOverload,
            setNodeFromStructure: (node, structure) => node.set(structure),
            expectedSyntaxKind: typescript_1.SyntaxKind.Constructor
        });
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        const hasImplementation = this.getImplementation() != null;
        const isOverload = this.isOverload();
        const basePrototype = isOverload && hasImplementation ? exports.ConstructorDeclarationOverloadBase.prototype : exports.ConstructorDeclarationBase.prototype;
        return callBaseGetStructure_1.callBaseGetStructure(basePrototype, this, getStructure(this));
        function getStructure(thisNode) {
            // this is not the best typing... unit tests will catch issues though
            if (hasImplementation && isOverload)
                return getSpecificOverloadStructure();
            return getSpecificStructure();
            function getSpecificOverloadStructure() {
                return { kind: structures_1.StructureKind.ConstructorOverload };
            }
            function getSpecificStructure() {
                if (!hasImplementation)
                    return { kind: structures_1.StructureKind.Constructor };
                else
                    return {
                        kind: structures_1.StructureKind.Constructor,
                        overloads: thisNode.getOverloads().map(o => o.getStructure())
                    };
            }
        }
    }
}
exports.ConstructorDeclaration = ConstructorDeclaration;
