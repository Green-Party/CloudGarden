"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getStructureFuncs = require("../../../manipulation/helpers/getStructureFunctions");
const structures_1 = require("../../../structures");
const typescript_1 = require("../../../typescript");
const base_1 = require("../base");
const callBaseSet_1 = require("../callBaseSet");
const function_1 = require("../function");
const base_2 = require("./base");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const ClassElement_1 = require("./ClassElement");
exports.MethodDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(function_1.OverloadableNode(base_1.BodyableNode(base_1.DecoratableNode(base_2.AbstractableNode(base_1.ScopedNode(base_1.QuestionTokenableNode(base_1.StaticableNode(base_1.AsyncableNode(base_1.GeneratorableNode(function_1.FunctionLikeDeclaration(base_1.PropertyNamedNode(ClassElement_1.ClassElement)))))))))))));
exports.MethodDeclarationOverloadBase = base_1.JSDocableNode(base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.ScopedNode(base_1.TypeParameteredNode(base_2.AbstractableNode(base_1.QuestionTokenableNode(base_1.StaticableNode(base_1.AsyncableNode(base_1.ModifierableNode(base_1.GeneratorableNode(base_1.SignaturedDeclaration(ClassElement_1.ClassElement))))))))))));
class MethodDeclaration extends exports.MethodDeclarationBase {
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        callBaseSet_1.callBaseSet(exports.MethodDeclarationBase.prototype, this, structure);
        if (structure.overloads != null) {
            this.getOverloads().forEach(o => o.remove());
            this.addOverloads(structure.overloads);
        }
        return this;
    }
    /**
     * Add a method overload.
     * @param structure - Structure to add.
     */
    addOverload(structure) {
        return this.addOverloads([structure])[0];
    }
    /**
     * Add method overloads.
     * @param structures - Structures to add.
     */
    addOverloads(structures) {
        return this.insertOverloads(this.getOverloads().length, structures);
    }
    /**
     * Inserts a method overload.
     * @param index - Child index to insert at.
     * @param structure - Structures to insert.
     */
    insertOverload(index, structure) {
        return this.insertOverloads(index, [structure])[0];
    }
    /**
     * Inserts method overloads.
     * @param index - Child index to insert at.
     * @param structures - Structures to insert.
     */
    insertOverloads(index, structures) {
        const thisName = this.getName();
        const childCodes = structures.map(_ => `${thisName}();`);
        return function_1.insertOverloads({
            node: this,
            index,
            structures,
            childCodes,
            getThisStructure: getStructureFuncs.fromMethodDeclarationOverload,
            setNodeFromStructure: (node, structure) => node.set(structure),
            expectedSyntaxKind: typescript_1.SyntaxKind.MethodDeclaration
        });
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        const hasImplementation = this.getImplementation() != null;
        const isOverload = this.isOverload();
        const basePrototype = isOverload && hasImplementation ? exports.MethodDeclarationOverloadBase.prototype : exports.MethodDeclarationBase.prototype;
        return callBaseGetStructure_1.callBaseGetStructure(basePrototype, this, getStructure(this));
        function getStructure(thisNode) {
            if (hasImplementation && isOverload)
                return getOverloadSpecificStructure();
            return getSpecificStructure();
            function getOverloadSpecificStructure() {
                return { kind: structures_1.StructureKind.MethodOverload };
            }
            function getSpecificStructure() {
                if (!hasImplementation)
                    return { kind: structures_1.StructureKind.Method };
                else
                    return {
                        kind: structures_1.StructureKind.Method,
                        overloads: thisNode.getOverloads().map(o => o.getStructure())
                    };
            }
        }
    }
}
exports.MethodDeclaration = MethodDeclaration;
