"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const typescript_1 = require("../../../typescript");
const utils_1 = require("../../../utils");
const Node_1 = require("../common/Node");
const structures_1 = require("../../../structures");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const callBaseSet_1 = require("../callBaseSet");
exports.DecoratorBase = Node_1.Node;
class Decorator extends exports.DecoratorBase {
    /**
     * Gets the decorator name.
     */
    getName() {
        return this.getNameNode().getText();
    }
    /**
     * Gets the name node of the decorator.
     */
    getNameNode() {
        if (this.isDecoratorFactory()) {
            const callExpression = this.getCallExpression();
            return getIdentifierFromName(callExpression.getExpression());
        }
        return getIdentifierFromName(this.getExpression());
        function getIdentifierFromName(expression) {
            const identifier = getNameFromExpression(expression);
            if (!utils_1.TypeGuards.isIdentifier(identifier)) {
                throw new errors.NotImplementedError(`Expected the decorator expression '${identifier.getText()}' to be an identifier, ` +
                    `but it wasn't. Please report this as a bug.`);
            }
            return identifier;
        }
        function getNameFromExpression(expression) {
            if (utils_1.TypeGuards.isPropertyAccessExpression(expression))
                return expression.getNameNode();
            return expression;
        }
    }
    /**
     * Gets the full decorator name.
     */
    getFullName() {
        const sourceFile = this.getSourceFile();
        if (this.isDecoratorFactory())
            return this.getCallExpression().getExpression().getText();
        return this.compilerNode.expression.getText(sourceFile.compilerNode);
    }
    /**
     * Gets if the decorator is a decorator factory.
     */
    isDecoratorFactory() {
        return this.compilerNode.expression.kind === typescript_1.SyntaxKind.CallExpression;
    }
    /**
     * Set if this decorator is a decorator factory.
     * @param isDecoratorFactory - If it should be a decorator factory or not.
     */
    setIsDecoratorFactory(isDecoratorFactory) {
        if (this.isDecoratorFactory() === isDecoratorFactory)
            return this;
        if (isDecoratorFactory) {
            const expression = this.getExpression();
            const expressionText = expression.getText();
            manipulation_1.insertIntoParentTextRange({
                parent: this,
                insertPos: expression.getStart(),
                newText: `${expressionText}()`,
                replacing: {
                    textLength: expressionText.length
                },
                customMappings: newParent => {
                    // the expression will move into the call expression
                    return [{ currentNode: expression, newNode: newParent.expression.expression }];
                }
            });
        }
        else {
            const callExpression = this.getCallExpressionOrThrow();
            const expression = callExpression.getExpression();
            const expressionText = expression.getText();
            manipulation_1.insertIntoParentTextRange({
                parent: this,
                insertPos: callExpression.getStart(),
                newText: `${expressionText}`,
                replacing: {
                    textLength: callExpression.getWidth()
                },
                customMappings: newParent => {
                    // the expression will move out of the call expression
                    return [{ currentNode: expression, newNode: newParent.expression }];
                }
            });
        }
        return this;
    }
    /**
     * Gets the call expression if a decorator factory, or throws.
     */
    getCallExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getCallExpression(), "Expected to find a call expression.");
    }
    /**
     * Gets the call expression if a decorator factory.
     */
    getCallExpression() {
        if (!this.isDecoratorFactory())
            return undefined;
        return this.getExpression();
    }
    /**
     * Gets the expression.
     */
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    /**
     * Gets the decorator's arguments from its call expression.
     */
    getArguments() {
        const callExpression = this.getCallExpression();
        return callExpression == null ? [] : callExpression.getArguments();
    }
    /**
     * Gets the decorator's type arguments from its call expression.
     */
    getTypeArguments() {
        const callExpression = this.getCallExpression();
        return callExpression == null ? [] : callExpression.getTypeArguments();
    }
    /**
     * Adds a type argument.
     * @param argumentTexts - Argument text.
     */
    addTypeArgument(argumentText) {
        return this.getCallExpressionOrThrow().addTypeArgument(argumentText);
    }
    /**
     * Adds type arguments.
     * @param argumentTexts - Argument texts.
     */
    addTypeArguments(argumentTexts) {
        return this.getCallExpressionOrThrow().addTypeArguments(argumentTexts);
    }
    /**
     * Inserts a type argument.
     * @param index - Child index to insert at.
     * @param argumentTexts - Argument text.
     */
    insertTypeArgument(index, argumentText) {
        return this.getCallExpressionOrThrow().insertTypeArgument(index, argumentText);
    }
    /**
     * Inserts type arguments.
     * @param index - Child index to insert at.
     * @param argumentTexts - Argument texts.
     */
    insertTypeArguments(index, argumentTexts) {
        return this.getCallExpressionOrThrow().insertTypeArguments(index, argumentTexts);
    }
    removeTypeArgument(typeArgOrIndex) {
        const callExpression = this.getCallExpression();
        if (callExpression == null)
            throw new errors.InvalidOperationError("Cannot remove a type argument from a decorator that has no type arguments.");
        callExpression.removeTypeArgument(typeArgOrIndex);
        return this;
    }
    /**
     * Adds an argument.
     * @param argumentTexts - Argument text.
     */
    addArgument(argumentText) {
        return this.addArguments([argumentText])[0];
    }
    /**
     * Adds arguments.
     * @param argumentTexts - Argument texts.
     */
    addArguments(argumentTexts) {
        return this.insertArguments(this.getArguments().length, argumentTexts);
    }
    /**
     * Inserts an argument.
     * @param index - Child index to insert at.
     * @param argumentTexts - Argument text.
     */
    insertArgument(index, argumentText) {
        return this.insertArguments(index, [argumentText])[0];
    }
    /**
     * Inserts arguments.
     * @param index - Child index to insert at.
     * @param argumentTexts - Argument texts.
     */
    insertArguments(index, argumentTexts) {
        this.setIsDecoratorFactory(true);
        return this.getCallExpressionOrThrow().insertArguments(index, argumentTexts);
    }
    removeArgument(argOrIndex) {
        const callExpression = this.getCallExpression();
        if (callExpression == null)
            throw new errors.InvalidOperationError("Cannot remove an argument from a decorator that has no arguments.");
        callExpression.removeArgument(argOrIndex);
        return this;
    }
    /**
     * Removes this decorator.
     */
    remove() {
        const thisStartLinePos = this.getStartLinePos();
        const previousDecorator = this.getPreviousSiblingIfKind(typescript_1.SyntaxKind.Decorator);
        if (previousDecorator != null && previousDecorator.getStartLinePos() === thisStartLinePos) {
            manipulation_1.removeChildren({
                children: [this],
                removePrecedingSpaces: true
            });
        }
        else
            manipulation_1.removeChildrenWithFormattingFromCollapsibleSyntaxList({
                children: [this],
                getSiblingFormatting: (parent, sibling) => sibling.getStartLinePos() === thisStartLinePos ? manipulation_1.FormattingKind.Space : manipulation_1.FormattingKind.Newline
            });
    }
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        callBaseSet_1.callBaseSet(exports.DecoratorBase.prototype, this, structure);
        if (structure.name != null)
            this.getNameNode().replaceWithText(structure.name);
        if (structure.arguments != null) {
            this.setIsDecoratorFactory(true);
            this.getArguments().map(a => this.removeArgument(a));
            this.addArguments(structure.arguments);
        }
        if (structure.typeArguments != null && structure.typeArguments.length > 0) {
            this.setIsDecoratorFactory(true);
            this.getTypeArguments().map(a => this.removeTypeArgument(a));
            this.addTypeArguments(structure.typeArguments);
        }
        return this;
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        const isDecoratorFactory = this.isDecoratorFactory();
        return callBaseGetStructure_1.callBaseGetStructure(exports.DecoratorBase.prototype, this, {
            kind: structures_1.StructureKind.Decorator,
            name: this.getName(),
            arguments: isDecoratorFactory ? this.getArguments().map(arg => arg.getText()) : undefined,
            typeArguments: isDecoratorFactory ? this.getTypeArguments().map(arg => arg.getText()) : undefined
        });
    }
}
exports.Decorator = Decorator;
