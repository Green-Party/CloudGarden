"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const structures_1 = require("../../../structures");
const utils_1 = require("../../../utils");
const typescript_1 = require("../../../typescript");
const base_1 = require("../base");
const callBaseSet_1 = require("../callBaseSet");
const common_1 = require("../common");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
exports.VariableDeclarationBase = base_1.ExportGetableNode(base_1.ExclamationTokenableNode(base_1.TypedNode(base_1.InitializerExpressionableNode(base_1.BindingNamedNode(common_1.Node)))));
class VariableDeclaration extends exports.VariableDeclarationBase {
    /**
     * Removes this variable declaration.
     */
    remove() {
        const parent = this.getParentOrThrow();
        switch (parent.getKind()) {
            case typescript_1.SyntaxKind.VariableDeclarationList:
                removeFromDeclarationList(this);
                break;
            case typescript_1.SyntaxKind.CatchClause:
                removeFromCatchClause(this);
                break;
            default:
                throw new errors.NotImplementedError(`Not implemented for syntax kind: ${parent.getKindName()}`);
        }
        function removeFromDeclarationList(node) {
            const variableStatement = parent.getParentIfKindOrThrow(typescript_1.SyntaxKind.VariableStatement);
            const declarations = variableStatement.getDeclarations();
            if (declarations.length === 1)
                variableStatement.remove();
            else
                manipulation_1.removeCommaSeparatedChild(node);
        }
        function removeFromCatchClause(node) {
            manipulation_1.removeChildren({
                children: [
                    node.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.OpenParenToken),
                    node,
                    node.getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.CloseParenToken)
                ],
                removePrecedingSpaces: true
            });
        }
    }
    /**
     * Gets the corresponding variable statement if it exists. Throws for variable declarations in for statements.
     */
    getVariableStatementOrThrow() {
        return errors.throwIfNullOrUndefined(this.getVariableStatement(), "Expected the grandparent to be a variable statement.");
    }
    /**
     * Gets the corresponding variable statement if it exists. Returns undefined for variable declarations in for statements.
     */
    getVariableStatement() {
        const grandParent = this.getParentOrThrow().getParentOrThrow();
        return utils_1.TypeGuards.isVariableStatement(grandParent) ? grandParent : undefined;
    }
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        callBaseSet_1.callBaseSet(exports.VariableDeclarationBase.prototype, this, structure);
        return this;
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        return callBaseGetStructure_1.callBaseGetStructure(exports.VariableDeclarationBase.prototype, this, {
            kind: structures_1.StructureKind.VariableDeclaration
        });
    }
}
exports.VariableDeclaration = VariableDeclaration;
