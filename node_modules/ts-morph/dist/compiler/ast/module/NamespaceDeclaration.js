"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const structures_1 = require("../../../structures");
const typescript_1 = require("../../../typescript");
const base_1 = require("../base");
const utils_1 = require("../../../utils");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const callBaseSet_1 = require("../callBaseSet");
const statement_1 = require("../statement");
const NamespaceChildableNode_1 = require("./NamespaceChildableNode");
const NamespaceDeclarationKind_1 = require("./NamespaceDeclarationKind");
exports.NamespaceDeclarationBase = base_1.ModuledNode(base_1.UnwrappableNode(base_1.TextInsertableNode(base_1.BodiedNode(NamespaceChildableNode_1.NamespaceChildableNode(statement_1.StatementedNode(base_1.JSDocableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement)))))))))));
class NamespaceDeclaration extends exports.NamespaceDeclarationBase {
    /**
     * Gets the full name of the namespace.
     */
    getName() {
        return this.getNameNodes().map(n => n.getText()).join(".");
    }
    /**
     * Sets the name without renaming references.
     * @param newName - New full namespace name.
     */
    setName(newName) {
        const nameNodes = this.getNameNodes();
        const openIssueText = `Please open an issue if you really need this and I'll up the priority.`;
        if (nameNodes.length > 1)
            throw new errors.NotImplementedError(`Not implemented to set a namespace name that uses dot notation. ${openIssueText}`);
        if (newName.indexOf(".") >= 0)
            throw new errors.NotImplementedError(`Not implemented to set a namespace name to a name containing a period. ${openIssueText}`);
        if (newName !== "global")
            addNamespaceKeywordIfNecessary(this);
        nameNodes[0].replaceWithText(newName);
        return this;
    }
    /**
     * Renames the name.
     * @param newName - New name.
     */
    rename(newName) {
        const nameNodes = this.getNameNodes();
        if (nameNodes.length > 1)
            throw new errors.NotSupportedError(`Cannot rename a namespace name that uses dot notation. Rename the individual nodes via .${"getNameNodes"}()`);
        if (newName.indexOf(".") >= 0)
            throw new errors.NotSupportedError(`Cannot rename a namespace name to a name containing a period.`);
        if (newName !== "global")
            addNamespaceKeywordIfNecessary(this);
        nameNodes[0].rename(newName);
        return this;
    }
    /**
     * Gets the name nodes.
     */
    getNameNodes() {
        const nodes = [];
        let current = this;
        do {
            nodes.push(this._getNodeFromCompilerNode(current.compilerNode.name));
            current = current.getFirstChildByKind(typescript_1.SyntaxKind.ModuleDeclaration);
        } while (current != null);
        return nodes;
    }
    /**
     * Gets if this namespace has a namespace keyword.
     */
    hasNamespaceKeyword() {
        return this.getDeclarationKind() === NamespaceDeclarationKind_1.NamespaceDeclarationKind.Namespace;
    }
    /**
     * Gets if this namespace has a namespace keyword.
     */
    hasModuleKeyword() {
        return this.getDeclarationKind() === NamespaceDeclarationKind_1.NamespaceDeclarationKind.Module;
    }
    /**
     * Sets the namespace declaration kind.
     * @param kind - Kind to set.
     */
    setDeclarationKind(kind) {
        if (this.getDeclarationKind() === kind)
            return this;
        if (kind === NamespaceDeclarationKind_1.NamespaceDeclarationKind.Global) {
            const declarationKindKeyword = this.getDeclarationKindKeyword();
            this.getNameNode().replaceWithText("global");
            if (declarationKindKeyword != null)
                manipulation_1.removeChildren({
                    children: [declarationKindKeyword],
                    removeFollowingNewLines: true,
                    removeFollowingSpaces: true
                });
        }
        else {
            const declarationKindKeyword = this.getDeclarationKindKeyword();
            if (declarationKindKeyword != null)
                declarationKindKeyword.replaceWithText(kind);
            else
                manipulation_1.insertIntoParentTextRange({
                    parent: this,
                    insertPos: this.getNameNode().getStart(),
                    newText: kind + " "
                });
        }
        return this;
    }
    /**
     * Gets the namesapce declaration kind.
     */
    getDeclarationKind() {
        const declarationKeyword = this.getDeclarationKindKeyword();
        if (declarationKeyword == null)
            return NamespaceDeclarationKind_1.NamespaceDeclarationKind.Global;
        return declarationKeyword.getKind() === typescript_1.SyntaxKind.NamespaceKeyword ? NamespaceDeclarationKind_1.NamespaceDeclarationKind.Namespace : NamespaceDeclarationKind_1.NamespaceDeclarationKind.Module;
    }
    /**
     * Gets the namespace or module keyword or returns undefined if it's global.
     */
    getDeclarationKindKeyword() {
        const keyword = this.getFirstChild(child => child.getKind() === typescript_1.SyntaxKind.NamespaceKeyword ||
            child.getKind() === typescript_1.SyntaxKind.ModuleKeyword);
        /* istanbul ignore if */
        if (keyword == null)
            return undefined;
        return keyword;
    }
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        if (structure.name != null && structure.name !== "global")
            addNamespaceKeywordIfNecessary(this);
        callBaseSet_1.callBaseSet(exports.NamespaceDeclarationBase.prototype, this, structure);
        if (structure.declarationKind != null)
            this.setDeclarationKind(structure.declarationKind);
        return this;
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        return callBaseGetStructure_1.callBaseGetStructure(exports.NamespaceDeclarationBase.prototype, this, {
            kind: structures_1.StructureKind.Namespace,
            declarationKind: this.getDeclarationKind()
        });
    }
    /** @internal */
    _getInnerBody() {
        let node = this.getBody();
        while (utils_1.TypeGuards.isBodiedNode(node) && node.compilerNode.statements == null)
            node = node.getBody();
        return node;
    }
}
exports.NamespaceDeclaration = NamespaceDeclaration;
function addNamespaceKeywordIfNecessary(namespaceDec) {
    if (namespaceDec.getDeclarationKind() === NamespaceDeclarationKind_1.NamespaceDeclarationKind.Global)
        namespaceDec.setDeclarationKind(NamespaceDeclarationKind_1.NamespaceDeclarationKind.Namespace);
}
