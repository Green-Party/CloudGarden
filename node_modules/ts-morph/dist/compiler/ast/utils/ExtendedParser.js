"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("../../../typescript");
const CommentNodeParser_1 = require("./CommentNodeParser");
const hasParsedTokens_1 = require("./hasParsedTokens");
const forEachChildSaver = new WeakMap();
const getChildrenSaver = new WeakMap();
/**
 * Parser that parses around nodes for comments.
 */
class ExtendedParser {
    /** Gets the `#statements`, `#members`, or `#properties` array with comment nodes. */
    static getContainerArray(container, sourceFile) {
        return CommentNodeParser_1.CommentNodeParser.getOrParseChildren(container, sourceFile);
    }
    static getCompilerChildrenFast(node, sourceFile) {
        if (hasParsedTokens_1.hasParsedTokens(node))
            return ExtendedParser.getCompilerChildren(node, sourceFile);
        return ExtendedParser.getCompilerForEachChildren(node, sourceFile);
    }
    static getCompilerForEachChildren(node, sourceFile) {
        if (CommentNodeParser_1.CommentNodeParser.shouldParseChildren(node)) {
            let result = forEachChildSaver.get(node);
            if (result == null) {
                result = getForEachChildren();
                mergeInComments(result, CommentNodeParser_1.CommentNodeParser.getOrParseChildren(node, sourceFile));
                forEachChildSaver.set(node, result);
            }
            return result;
        }
        return getForEachChildren();
        function getForEachChildren() {
            const children = [];
            node.forEachChild(child => {
                children.push(child);
            });
            return children;
        }
    }
    static getCompilerChildren(node, sourceFile) {
        if (isStatementMemberOrPropertyHoldingSyntaxList()) {
            let result = getChildrenSaver.get(node);
            if (result == null) {
                // @code-fence-allow(getChildren): This merges in comment nodes.
                result = [...node.getChildren(sourceFile)]; // make a copy; do not modify the compiler api's array
                mergeInComments(result, CommentNodeParser_1.CommentNodeParser.getOrParseChildren(node, sourceFile));
                getChildrenSaver.set(node, result);
            }
            return result;
        }
        // @code-fence-allow(getChildren): No need to merge in comment nodes.
        return node.getChildren(sourceFile);
        function isStatementMemberOrPropertyHoldingSyntaxList() {
            if (node.kind !== typescript_1.ts.SyntaxKind.SyntaxList)
                return false;
            const parent = node.parent;
            if (!CommentNodeParser_1.CommentNodeParser.shouldParseChildren(parent))
                return false;
            // is this the correct syntax list?
            return CommentNodeParser_1.CommentNodeParser.getContainerBodyPos(parent, sourceFile) === node.pos;
        }
    }
}
exports.ExtendedParser = ExtendedParser;
function mergeInComments(nodes, otherNodes) {
    // insert all the comments in the correct place (be as fast as possible here as this is used a lot)
    let currentIndex = 0;
    // assumes the arrays are sorted
    for (const child of otherNodes) {
        // do not use .filter to prevent needless allocations
        if (child.kind !== typescript_1.SyntaxKind.SingleLineCommentTrivia && child.kind !== typescript_1.SyntaxKind.MultiLineCommentTrivia)
            continue;
        while (currentIndex < nodes.length && nodes[currentIndex].end < child.end)
            currentIndex++;
        nodes.splice(currentIndex, 0, child);
        currentIndex++;
    }
}
