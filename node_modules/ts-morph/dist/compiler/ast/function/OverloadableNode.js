"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const utils_1 = require("../../../utils");
function OverloadableNode(Base) {
    return class extends Base {
        getOverloads() {
            return getOverloadsAndImplementation(this).filter(n => n.isOverload());
        }
        getImplementation() {
            if (this.isImplementation())
                return this;
            return getOverloadsAndImplementation(this).find(n => n.isImplementation());
        }
        getImplementationOrThrow() {
            return errors.throwIfNullOrUndefined(this.getImplementation(), "Expected to find a corresponding implementation for the overload.");
        }
        isOverload() {
            return !this.isImplementation();
        }
        isImplementation() {
            return this.getBody() != null;
        }
    };
}
exports.OverloadableNode = OverloadableNode;
function getOverloadsAndImplementation(node) {
    const parent = node.getParentOrThrow();
    const name = getNameIfNamedNode(node);
    const kind = node.getKind();
    return parent.forEachChildAsArray().filter(n => {
        const hasSameName = getNameIfNamedNode(n) === name;
        const hasSameKind = n.getKind() === kind;
        return hasSameName && hasSameKind;
    });
}
function getNameIfNamedNode(node) {
    const nodeAsNamedNode = node;
    if (nodeAsNamedNode.getName instanceof Function)
        return nodeAsNamedNode.getName();
    return undefined;
}
/**
 * @internal
 */
function insertOverloads(opts) {
    if (opts.structures.length === 0)
        return [];
    const overloads = opts.node.getOverloads();
    const overloadsCount = overloads.length;
    const parentSyntaxList = opts.node.getParentSyntaxListOrThrow();
    const firstIndex = overloads.length > 0 ? overloads[0].getChildIndex() : opts.node.getChildIndex();
    const index = manipulation_1.verifyAndGetIndex(opts.index, overloadsCount);
    const mainIndex = firstIndex + index;
    const thisStructure = opts.getThisStructure(opts.node.getImplementation() || opts.node);
    const structures = [...opts.structures];
    for (let i = 0; i < structures.length; i++) {
        structures[i] = utils_1.ObjectUtils.assign(utils_1.ObjectUtils.assign({}, thisStructure), structures[i]);
        // structures[i] = {...thisStructure, ...structures[i]}; // not supported by TS as of 2.4.1
    }
    const indentationText = opts.node.getIndentationText();
    const newLineKind = opts.node._context.manipulationSettings.getNewLineKindAsString();
    manipulation_1.insertIntoParentTextRange({
        parent: parentSyntaxList,
        insertPos: opts.node.getNonWhitespaceStart(),
        newText: opts.childCodes.map((c, i) => (i > 0 ? indentationText : "") + c).join(newLineKind) + newLineKind + indentationText
    });
    const children = manipulation_1.getRangeWithoutCommentsFromArray(parentSyntaxList.getChildren(), mainIndex, structures.length, opts.expectedSyntaxKind);
    // todo: Do not set here... this should be printed
    children.forEach((child, i) => {
        opts.setNodeFromStructure(child, structures[i]);
    });
    return children;
}
exports.insertOverloads = insertOverloads;
