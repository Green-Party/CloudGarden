"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const typescript_1 = require("../../../typescript");
const utils_1 = require("../../../utils");
const callBaseSet_1 = require("../callBaseSet");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
function DecoratableNode(Base) {
    return class extends Base {
        getDecorator(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getDecorators(), nameOrFindFunction);
        }
        getDecoratorOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getDecorator(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("decorator", nameOrFindFunction));
        }
        getDecorators() {
            if (this.compilerNode.decorators == null)
                return [];
            return this.compilerNode.decorators.map(d => this._getNodeFromCompilerNode(d));
        }
        addDecorator(structure) {
            return this.insertDecorator(manipulation_1.getEndIndexFromArray(this.compilerNode.decorators), structure);
        }
        addDecorators(structures) {
            return this.insertDecorators(manipulation_1.getEndIndexFromArray(this.compilerNode.decorators), structures);
        }
        insertDecorator(index, structure) {
            return this.insertDecorators(index, [structure])[0];
        }
        insertDecorators(index, structures) {
            if (utils_1.ArrayUtils.isNullOrEmpty(structures))
                return [];
            const decoratorLines = getDecoratorLines(this, structures);
            const decorators = this.getDecorators();
            index = manipulation_1.verifyAndGetIndex(index, decorators.length);
            const formattingKind = getDecoratorFormattingKind(this, decorators);
            const previousDecorator = decorators[index - 1];
            const decoratorCode = manipulation_1.getNewInsertCode({
                structures,
                newCodes: decoratorLines,
                parent: this,
                indentationText: this.getIndentationText(),
                getSeparator: () => formattingKind,
                previousFormattingKind: previousDecorator == null ? manipulation_1.FormattingKind.None : formattingKind,
                nextFormattingKind: previousDecorator == null ? formattingKind : manipulation_1.FormattingKind.None
            });
            manipulation_1.insertIntoParentTextRange({
                parent: decorators.length === 0 ? this : decorators[0].getParentSyntaxListOrThrow(),
                insertPos: decorators[index - 1] == null ? this.getStart() : decorators[index - 1].getEnd(),
                newText: decoratorCode
            });
            return manipulation_1.getNodesToReturn(this.getDecorators(), index, structures.length);
        }
        set(structure) {
            callBaseSet_1.callBaseSet(Base.prototype, this, structure);
            if (structure.decorators != null) {
                this.getDecorators().forEach(d => d.remove());
                this.addDecorators(structure.decorators);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure_1.callBaseGetStructure(Base.prototype, this, {
                decorators: this.getDecorators().map(d => d.getStructure())
            });
        }
    };
}
exports.DecoratableNode = DecoratableNode;
function getDecoratorLines(node, structures) {
    const lines = [];
    for (const structure of structures) {
        // todo: temporary code... refactor this later
        const writer = node._getWriter();
        const structurePrinter = node._context.structurePrinterFactory.forDecorator();
        structurePrinter.printText(writer, structure);
        lines.push(writer.toString());
    }
    return lines;
}
function getDecoratorFormattingKind(parent, currentDecorators) {
    const sameLine = areDecoratorsOnSameLine(parent, currentDecorators);
    return sameLine ? manipulation_1.FormattingKind.Space : manipulation_1.FormattingKind.Newline;
}
function areDecoratorsOnSameLine(parent, currentDecorators) {
    if (currentDecorators.length <= 1)
        return parent.getKind() === typescript_1.SyntaxKind.Parameter;
    const startLinePos = currentDecorators[0].getStartLinePos();
    for (let i = 1; i < currentDecorators.length; i++) {
        if (currentDecorators[i].getStartLinePos() !== startLinePos)
            return false;
    }
    return true;
}
