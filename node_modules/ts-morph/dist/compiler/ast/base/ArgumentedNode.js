"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const typescript_1 = require("../../../typescript");
const utils_1 = require("../../../utils");
function ArgumentedNode(Base) {
    return class extends Base {
        getArguments() {
            return this.compilerNode.arguments.map(a => this._getNodeFromCompilerNode(a));
        }
        addArgument(argumentText) {
            return this.addArguments([argumentText])[0];
        }
        addArguments(argumentTexts) {
            return this.insertArguments(this.getArguments().length, argumentTexts);
        }
        insertArgument(index, argumentText) {
            return this.insertArguments(index, [argumentText])[0];
        }
        insertArguments(index, argumentTexts) {
            if (argumentTexts instanceof Function)
                argumentTexts = [argumentTexts];
            if (utils_1.ArrayUtils.isNullOrEmpty(argumentTexts))
                return [];
            const originalArgs = this.getArguments();
            index = manipulation_1.verifyAndGetIndex(index, originalArgs.length);
            const writer = this._getWriterWithQueuedChildIndentation();
            for (let i = 0; i < argumentTexts.length; i++) {
                writer.conditionalWrite(i > 0, ", ");
                utils_1.printTextFromStringOrWriter(writer, argumentTexts[i]);
            }
            manipulation_1.insertIntoCommaSeparatedNodes({
                parent: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenParenToken).getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.SyntaxList),
                currentNodes: originalArgs,
                insertIndex: index,
                newText: writer.toString()
            });
            const newArgs = this.getArguments();
            return manipulation_1.getNodesToReturn(newArgs, index, newArgs.length - originalArgs.length);
        }
        removeArgument(argOrIndex) {
            const args = this.getArguments();
            if (args.length === 0)
                throw new errors.InvalidOperationError("Cannot remove an argument when none exist.");
            const argToRemove = typeof argOrIndex === "number" ? getArgFromIndex(argOrIndex) : argOrIndex;
            manipulation_1.removeCommaSeparatedChild(argToRemove);
            return this;
            function getArgFromIndex(index) {
                return args[manipulation_1.verifyAndGetIndex(index, args.length - 1)];
            }
        }
    };
}
exports.ArgumentedNode = ArgumentedNode;
