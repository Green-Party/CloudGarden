"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const manipulation_1 = require("../../../../manipulation");
const typescript_1 = require("../../../../typescript");
const utils_1 = require("../../../../utils");
const base_1 = require("../../base");
const structures_1 = require("../../../../structures");
const callBaseSet_1 = require("../../callBaseSet");
const callBaseGetStructure_1 = require("../../callBaseGetStructure");
const ObjectLiteralElement_1 = require("./ObjectLiteralElement");
// This node only has a question token in order to tell the user about bad code.
// (See https://github.com/Microsoft/TypeScript/pull/5121/files)
exports.PropertyAssignmentBase = base_1.InitializerExpressionGetableNode(base_1.QuestionTokenableNode(base_1.PropertyNamedNode(ObjectLiteralElement_1.ObjectLiteralElement)));
class PropertyAssignment extends exports.PropertyAssignmentBase {
    /**
     * Removes the initializer and returns the new shorthand property assignment.
     *
     * Note: The current node will no longer be valid because it's no longer a property assignment.
     */
    removeInitializer() {
        const initializer = this.getInitializerOrThrow();
        const colonToken = initializer.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.ColonToken);
        const childIndex = this.getChildIndex();
        const sourceFileText = this._sourceFile.getFullText();
        const insertPos = this.getStart();
        const newText = sourceFileText.substring(insertPos, colonToken.getPos()) + sourceFileText.substring(initializer.getEnd(), this.getEnd());
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        manipulation_1.insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: {
                textLength: this.getWidth()
            }
        });
        return parent.getChildAtIndexIfKindOrThrow(childIndex, typescript_1.SyntaxKind.ShorthandPropertyAssignment);
    }
    /**
     * Sets the initializer.
     * @param textOrWriterFunction - New text ot set for the initializer.
     */
    setInitializer(textOrWriterFunction) {
        const initializer = this.getInitializerOrThrow();
        manipulation_1.insertIntoParentTextRange({
            insertPos: initializer.getStart(),
            newText: utils_1.getTextFromStringOrWriter(this._getWriterWithQueuedChildIndentation(), textOrWriterFunction),
            parent: this,
            replacing: {
                textLength: initializer.getWidth()
            }
        });
        return this;
    }
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        callBaseSet_1.callBaseSet(exports.PropertyAssignmentBase.prototype, this, structure);
        if (structure.initializer != null)
            this.setInitializer(structure.initializer);
        else if (structure.hasOwnProperty("initializer"))
            return this.removeInitializer();
        return this;
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        const initializer = this.getInitializerOrThrow();
        const structure = callBaseGetStructure_1.callBaseGetStructure(exports.PropertyAssignmentBase.prototype, this, {
            kind: structures_1.StructureKind.PropertyAssignment,
            initializer: initializer.getText()
        });
        // only has a question token for bad code. Don't include it in the structure.
        delete structure.hasQuestionToken;
        return structure;
    }
}
exports.PropertyAssignment = PropertyAssignment;
