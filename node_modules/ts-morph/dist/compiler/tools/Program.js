"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../errors");
const typescript_1 = require("../../typescript");
const tsInternal = require("../../typescript/tsInternal");
const results_1 = require("./results");
const TypeChecker_1 = require("./TypeChecker");
/**
 * Wrapper around Program.
 */
class Program {
    /** @private */
    constructor(context, rootNames, host) {
        this._context = context;
        this._typeChecker = new TypeChecker_1.TypeChecker(this._context);
        this._reset(rootNames, host);
    }
    /**
     * Gets the underlying compiler program.
     */
    get compilerObject() {
        return this._getOrCreateCompilerObject();
    }
    /**
     * Gets if the internal compiler program is created.
     * @internal
     */
    _isCompilerProgramCreated() {
        return this._createdCompilerObject != null;
    }
    /**
     * Resets the program.
     * @internal
     */
    _reset(rootNames, host) {
        const compilerOptions = this._context.compilerOptions.get();
        this._getOrCreateCompilerObject = () => {
            // need to use ts.createProgram instead of languageService.getProgram() because the
            // program created by the language service is not fully featured (ex. does not write to the file system)
            if (this._createdCompilerObject == null) {
                this._createdCompilerObject = typescript_1.ts.createProgram(rootNames, compilerOptions, host, this._oldProgram);
                delete this._oldProgram;
            }
            return this._createdCompilerObject;
        };
        if (this._createdCompilerObject != null) {
            this._oldProgram = this._createdCompilerObject;
            delete this._createdCompilerObject;
        }
        this._typeChecker._reset(() => this.compilerObject.getTypeChecker());
    }
    /**
     * Get the program's type checker.
     */
    getTypeChecker() {
        return this._typeChecker;
    }
    /**
     * Asynchronously emits the TypeScript files as JavaScript files.
     * @param options - Options for emitting.
     */
    emit(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.writeFile) {
                const message = `Cannot specify a ${"writeFile"} option when emitting asynchrously. `
                    + `Use ${"emitSync"}() instead.`;
                throw new errors.InvalidOperationError(message);
            }
            const { fileSystemWrapper } = this._context;
            const promises = [];
            const emitResult = this._emit(Object.assign({ writeFile: (filePath, text, writeByteOrderMark) => {
                    promises.push(fileSystemWrapper.writeFile(filePath, writeByteOrderMark ? "\uFEFF" + text : text));
                } }, options));
            yield Promise.all(promises);
            return new results_1.EmitResult(this._context, emitResult);
        });
    }
    /**
     * Synchronously emits the TypeScript files as JavaScript files.
     * @param options - Options for emitting.
     * @remarks Use `emit()` as the asynchronous version will be much faster.
     */
    emitSync(options = {}) {
        return new results_1.EmitResult(this._context, this._emit(options));
    }
    /**
     * Emits the TypeScript files to JavaScript files to memory.
     * @param options - Options for emitting.
     */
    emitToMemory(options = {}) {
        const sourceFiles = [];
        const { fileSystemWrapper } = this._context;
        const emitResult = this._emit(Object.assign({ writeFile: (filePath, text, writeByteOrderMark) => {
                sourceFiles.push({
                    filePath: fileSystemWrapper.getStandardizedAbsolutePath(filePath),
                    text,
                    writeByteOrderMark: writeByteOrderMark || false
                });
            } }, options));
        return new results_1.MemoryEmitResult(this._context, emitResult, sourceFiles);
    }
    /** @internal */
    _emit(options = {}) {
        const targetSourceFile = options.targetSourceFile != null ? options.targetSourceFile.compilerNode : undefined;
        const { emitOnlyDtsFiles, customTransformers, writeFile } = options;
        const cancellationToken = undefined; // todo: expose this
        return this.compilerObject.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
    }
    /**
     * Gets the syntactic diagnostics.
     * @param sourceFile - Optional source file to filter by.
     */
    getSyntacticDiagnostics(sourceFile) {
        const compilerDiagnostics = this.compilerObject.getSyntacticDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnosticWithLocation(d));
    }
    /**
     * Gets the semantic diagnostics.
     * @param sourceFile - Optional source file to filter by.
     */
    getSemanticDiagnostics(sourceFile) {
        const compilerDiagnostics = this.compilerObject.getSemanticDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnostic(d));
    }
    /**
     * Gets the declaration diagnostics.
     * @param sourceFile - Optional source file to filter by.
     */
    getDeclarationDiagnostics(sourceFile) {
        const compilerDiagnostics = this.compilerObject.getDeclarationDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnosticWithLocation(d));
    }
    /**
     * Gets the global diagnostics.
     */
    getGlobalDiagnostics() {
        const compilerDiagnostics = this.compilerObject.getGlobalDiagnostics();
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnostic(d));
    }
    /**
     * Gets the emit module resolution kind.
     */
    getEmitModuleResolutionKind() {
        return tsInternal.getEmitModuleResolutionKind(this.compilerObject.getCompilerOptions());
    }
    /**
     * Gets if the provided source file was discovered while loading an external library.
     * @param sourceFile - Source file.
     */
    isSourceFileFromExternalLibrary(sourceFile) {
        // Do not use compilerObject.isSourceFileFromExternalLibrary because that method
        // will become out of date after a manipulation has happened to a source file.
        // Read more in sourceFile.isFromExternalLibrary()'s method body.
        return sourceFile.isFromExternalLibrary();
    }
}
exports.Program = Program;
