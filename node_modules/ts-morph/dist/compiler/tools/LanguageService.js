"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../errors");
const fileSystem_1 = require("../../fileSystem");
const manipulation_1 = require("../../manipulation");
const typescript_1 = require("../../typescript");
const utils_1 = require("../../utils");
const Program_1 = require("./Program");
const results_1 = require("./results");
class LanguageService {
    /**
     * Gets the compiler language service.
     */
    get compilerObject() {
        return this._compilerObject;
    }
    /** @private */
    constructor(context, opts) {
        const { resolutionHost = {} } = opts;
        this._context = context;
        let version = 0;
        const fileExistsSync = (path) => this._context.compilerFactory.containsSourceFileAtPath(path) || context.fileSystemWrapper.fileExistsSync(path);
        const languageServiceHost = {
            getCompilationSettings: () => context.compilerOptions.get(),
            getNewLine: () => context.manipulationSettings.getNewLineKindAsString(),
            getScriptFileNames: () => this._context.compilerFactory.getSourceFilePaths(),
            getScriptVersion: fileName => {
                const sourceFile = this._context.compilerFactory.getSourceFileFromCacheFromFilePath(fileName);
                if (sourceFile == null)
                    return (version++).toString();
                return this._context.compilerFactory.documentRegistry.getSourceFileVersion(sourceFile.compilerNode);
            },
            getScriptSnapshot: fileName => {
                if (!fileExistsSync(fileName))
                    return undefined;
                return typescript_1.ts.ScriptSnapshot.fromString(this._context.compilerFactory.addOrGetSourceFileFromFilePath(fileName, { markInProject: false }).getFullText());
            },
            getCurrentDirectory: () => context.fileSystemWrapper.getCurrentDirectory(),
            getDefaultLibFileName: options => {
                if (this._context.fileSystemWrapper.getFileSystem() instanceof fileSystem_1.DefaultFileSystemHost)
                    return typescript_1.ts.getDefaultLibFilePath(options);
                else
                    return utils_1.FileUtils.pathJoin(context.fileSystemWrapper.getCurrentDirectory(), "node_modules/typescript/lib/" + typescript_1.ts.getDefaultLibFileName(options));
            },
            useCaseSensitiveFileNames: () => true,
            readFile: (path, encoding) => {
                if (this._context.compilerFactory.containsSourceFileAtPath(path))
                    return this._context.compilerFactory.getSourceFileFromCacheFromFilePath(path).getFullText();
                return this._context.fileSystemWrapper.readFileSync(path, encoding);
            },
            fileExists: fileExistsSync,
            directoryExists: dirName => this._context.compilerFactory.containsDirectoryAtPath(dirName) || this._context.fileSystemWrapper.directoryExistsSync(dirName),
            resolveModuleNames: resolutionHost.resolveModuleNames,
            resolveTypeReferenceDirectives: resolutionHost.resolveTypeReferenceDirectives,
            getResolvedModuleWithFailedLookupLocationsFromCache: resolutionHost.getResolvedModuleWithFailedLookupLocationsFromCache
        };
        this._compilerHost = {
            getSourceFile: (fileName, languageVersion, onError) => {
                // todo: use languageVersion here?
                const sourceFile = this._context.compilerFactory.addOrGetSourceFileFromFilePath(fileName, { markInProject: false });
                return sourceFile == null ? undefined : sourceFile.compilerNode;
            },
            // getSourceFileByPath: (...) => {}, // not providing these will force it to use the file name as the file path
            // getDefaultLibLocation: (...) => {},
            getDefaultLibFileName: (options) => languageServiceHost.getDefaultLibFileName(options),
            writeFile: (filePath, data, writeByteOrderMark, onError, sourceFiles) => {
                this._context.fileSystemWrapper.writeFileSync(filePath, writeByteOrderMark ? "\uFEFF" + data : data);
            },
            getCurrentDirectory: () => languageServiceHost.getCurrentDirectory(),
            getDirectories: (path) => this._context.fileSystemWrapper.getDirectories(path),
            fileExists: (fileName) => languageServiceHost.fileExists(fileName),
            readFile: (fileName) => languageServiceHost.readFile(fileName),
            getCanonicalFileName: (fileName) => this._context.fileSystemWrapper.getStandardizedAbsolutePath(fileName),
            useCaseSensitiveFileNames: () => languageServiceHost.useCaseSensitiveFileNames(),
            getNewLine: () => languageServiceHost.getNewLine(),
            getEnvironmentVariable: (name) => process.env[name],
            directoryExists: dirName => languageServiceHost.directoryExists(dirName),
            resolveModuleNames: resolutionHost.resolveModuleNames,
            resolveTypeReferenceDirectives: resolutionHost.resolveTypeReferenceDirectives
        };
        this._compilerObject = typescript_1.ts.createLanguageService(languageServiceHost, this._context.compilerFactory.documentRegistry);
        this._program = new Program_1.Program(this._context, this._context.compilerFactory.getSourceFilePaths(), this._compilerHost);
        this._context.compilerFactory.onSourceFileAdded(() => this._resetProgram());
        this._context.compilerFactory.onSourceFileRemoved(() => this._resetProgram());
    }
    /**
     * Resets the program. This should be done whenever any modifications happen.
     * @internal
     */
    _resetProgram() {
        this._program._reset(this._context.compilerFactory.getSourceFilePaths(), this._compilerHost);
    }
    /**
     * Gets the language service's program.
     */
    getProgram() {
        return this._program;
    }
    /**
     * Rename the specified node.
     * @param node - Node to rename.
     * @param newName - New name for the node.
     * @param options - Options for renaming the node.
     */
    renameNode(node, newName, options = {}) {
        errors.throwIfWhitespaceOrNotString(newName, "newName");
        if (node.getText() === newName)
            return;
        this.renameLocations(this.findRenameLocations(node, options), newName);
    }
    /**
     * Rename the provided rename locations.
     * @param renameLocations - Rename locations.
     * @param newName - New name for the node.
     */
    renameLocations(renameLocations, newName) {
        const renameLocationsBySourceFile = new utils_1.KeyValueCache();
        for (const renameLocation of renameLocations) {
            const locations = renameLocationsBySourceFile.getOrCreate(renameLocation.getSourceFile(), () => []);
            locations.push(renameLocation);
        }
        for (const [sourceFile, locations] of renameLocationsBySourceFile.getEntries()) {
            manipulation_1.replaceSourceFileTextForRename({
                sourceFile,
                renameLocations: locations,
                newName
            });
        }
    }
    /**
     * Gets the definitions for the specified node.
     * @param node - Node.
     */
    getDefinitions(node) {
        return this.getDefinitionsAtPosition(node._sourceFile, node.getStart());
    }
    /**
     * Gets the definitions at the specified position.
     * @param sourceFile - Source file.
     * @param pos - Position.
     */
    getDefinitionsAtPosition(sourceFile, pos) {
        const results = this.compilerObject.getDefinitionAtPosition(sourceFile.getFilePath(), pos) || [];
        return results.map(info => this._context.compilerFactory.getDefinitionInfo(info));
    }
    /**
     * Gets the implementations for the specified node.
     * @param node - Node.
     */
    getImplementations(node) {
        return this.getImplementationsAtPosition(node._sourceFile, node.getStart());
    }
    /**
     * Gets the implementations at the specified position.
     * @param sourceFile - Source file.
     * @param pos - Position.
     */
    getImplementationsAtPosition(sourceFile, pos) {
        const results = this.compilerObject.getImplementationAtPosition(sourceFile.getFilePath(), pos) || [];
        return results.map(location => new results_1.ImplementationLocation(this._context, location));
    }
    /**
     * Finds references based on the specified node.
     * @param node - Node to find references for.
     */
    findReferences(node) {
        return this.findReferencesAtPosition(node._sourceFile, node.getStart());
    }
    /**
     * Finds the nodes that reference the definition(s) of the specified node.
     * @param node - Node.
     */
    findReferencesAsNodes(node) {
        const referencedSymbols = this.findReferences(node);
        return Array.from(getReferencingNodes());
        function* getReferencingNodes() {
            for (const referencedSymbol of referencedSymbols) {
                const isAlias = referencedSymbol.getDefinition().getKind() === typescript_1.ts.ScriptElementKind.alias;
                const references = referencedSymbol.getReferences();
                for (let i = 0; i < references.length; i++) {
                    // the first reference always seems to be the main definition... the other definitions
                    // could be constructed in initializers or elsewhere
                    const reference = references[i];
                    if (isAlias || !reference.isDefinition() || i > 0)
                        yield reference.getNode();
                }
            }
        }
    }
    /**
     * Finds references based on the specified position.
     * @param sourceFile - Source file.
     * @param pos - Position to find the reference at.
     */
    findReferencesAtPosition(sourceFile, pos) {
        const results = this.compilerObject.findReferences(sourceFile.getFilePath(), pos) || [];
        return results.map(s => this._context.compilerFactory.getReferencedSymbol(s));
    }
    /**
     * Find the rename locations for the specified node.
     * @param node - Node to get the rename locations for.
     * @param options - Options for renaming.
     */
    findRenameLocations(node, options = {}) {
        const renameLocations = this.compilerObject.findRenameLocations(node._sourceFile.getFilePath(), node.getStart(), options.renameInStrings || false, options.renameInComments || false) || [];
        return renameLocations.map(l => new results_1.RenameLocation(this._context, l));
    }
    /**
     * Gets the suggestion diagnostics.
     * @param filePathOrSourceFile - The source file or file path to get suggestions for.
     */
    getSuggestionDiagnostics(filePathOrSourceFile) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        const suggestionDiagnostics = this.compilerObject.getSuggestionDiagnostics(filePath);
        return suggestionDiagnostics.map(d => this._context.compilerFactory.getDiagnosticWithLocation(d));
    }
    /**
     * Gets the formatting edits for a range.
     * @param filePath - File path.
     * @param range - Position range.
     * @param formatSettings - Format code settings.
     */
    getFormattingEditsForRange(filePath, range, formatSettings) {
        return (this.compilerObject.getFormattingEditsForRange(filePath, range[0], range[1], this._getFilledSettings(formatSettings)) || []).map(e => new results_1.TextChange(e));
    }
    /**
     * Gets the formatting edits for a document.
     * @param filePath - File path of the source file.
     * @param formatSettings - Format code settings.
     */
    getFormattingEditsForDocument(filePath, formatSettings) {
        return (this.compilerObject.getFormattingEditsForDocument(filePath, this._getFilledSettings(formatSettings)) || []).map(e => new results_1.TextChange(e));
    }
    /**
     * Gets the formatted text for a document.
     * @param filePath - File path of the source file.
     * @param formatSettings - Format code settings.
     */
    getFormattedDocumentText(filePath, formatSettings) {
        const sourceFile = this._context.compilerFactory.getSourceFileFromCacheFromFilePath(filePath);
        if (sourceFile == null)
            throw new errors.FileNotFoundError(filePath);
        formatSettings = this._getFilledSettings(formatSettings);
        const formattingEdits = this.getFormattingEditsForDocument(filePath, formatSettings);
        let newText = manipulation_1.getTextFromFormattingEdits(sourceFile, formattingEdits);
        const newLineChar = formatSettings.newLineCharacter;
        if (formatSettings.ensureNewLineAtEndOfFile && !newText.endsWith(newLineChar))
            newText += newLineChar;
        return newText.replace(/\r?\n/g, newLineChar);
    }
    getEmitOutput(filePathOrSourceFile, emitOnlyDtsFiles) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        return new results_1.EmitOutput(this._context, filePath, this.compilerObject.getEmitOutput(filePath, emitOnlyDtsFiles));
    }
    getIdentationAtPosition(filePathOrSourceFile, position, settings) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        if (settings == null)
            settings = this._context.manipulationSettings.getEditorSettings();
        else
            utils_1.fillDefaultEditorSettings(settings, this._context.manipulationSettings);
        return this.compilerObject.getIndentationAtPosition(filePath, position, settings);
    }
    organizeImports(filePathOrSourceFile, formatSettings = {}, userPreferences = {}) {
        const scope = {
            type: "file",
            fileName: this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile)
        };
        return this.compilerObject.organizeImports(scope, this._getFilledSettings(formatSettings), this._getFilledUserPreferences(userPreferences))
            .map(fileTextChanges => new results_1.FileTextChanges(this._context, fileTextChanges));
    }
    /**
     * Gets the edit information for applying a refactor at a the provided position in a source file.
     * @param filePathOrSourceFile - File path or source file to get the edits for.
     * @param formatSettings - Fomat code settings.
     * @param positionOrRange - Position in the source file where to apply given refactor.
     * @param refactorName - Refactor name.
     * @param actionName - Refactor action name.
     * @param preferences - User preferences for refactoring.
     */
    getEditsForRefactor(filePathOrSourceFile, formatSettings, positionOrRange, refactorName, actionName, preferences = {}) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        const position = typeof positionOrRange === "number" ? positionOrRange : { pos: positionOrRange.getPos(), end: positionOrRange.getEnd() };
        const compilerObject = this.compilerObject.getEditsForRefactor(filePath, this._getFilledSettings(formatSettings), position, refactorName, actionName, this._getFilledUserPreferences(preferences));
        return compilerObject != null ? new results_1.RefactorEditInfo(this._context, compilerObject) : undefined;
    }
    /**
     * Gets file changes and actions to perform for the provided fixId.
     * @param filePathOrSourceFile - File path or source file to get the combined code fixes for.
     * @param fixId - Identifier for the code fix (ex. "fixMissingImport"). These ids are found in the `ts.codefix` namespace in the compiler api source.
     * @param formatSettings - Format code settings.
     * @param preferences - User preferences for refactoring.
     */
    getCombinedCodeFix(filePathOrSourceFile, fixId, formatSettings = {}, preferences = {}) {
        const compilerResult = this.compilerObject.getCombinedCodeFix({
            type: "file",
            fileName: this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile)
        }, fixId, this._getFilledSettings(formatSettings), this._getFilledUserPreferences(preferences || {}));
        return new results_1.CombinedCodeActions(this._context, compilerResult);
    }
    /**
     * Gets the edit information for applying a code fix at the provided text range in a source file.
     * @param filePathOrSourceFile - File path or source file to get the code fixes for.
     * @param start - Start position of the text range to be fixed.
     * @param end - End position of the text range to be fixed.
     * @param errorCodes - One or more error codes associated with the code fixes to retrieve.
     * @param formatOptions - Format code settings.
     * @param preferences - User preferences for refactoring.
     */
    getCodeFixesAtPosition(filePathOrSourceFile, start, end, errorCodes, formatOptions = {}, preferences = {}) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        const compilerResult = this.compilerObject.getCodeFixesAtPosition(filePath, start, end, errorCodes, this._getFilledSettings(formatOptions), this._getFilledUserPreferences(preferences || {}));
        return compilerResult.map(compilerObject => new results_1.CodeFixAction(this._context, compilerObject));
    }
    _getFilePathFromFilePathOrSourceFile(filePathOrSourceFile) {
        const filePath = typeof filePathOrSourceFile === "string"
            ? this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePathOrSourceFile)
            : filePathOrSourceFile.getFilePath();
        if (!this._context.compilerFactory.containsSourceFileAtPath(filePath))
            throw new errors.FileNotFoundError(filePath);
        return filePath;
    }
    _getFilledSettings(settings) {
        if (settings["_filled"]) // optimization
            return settings;
        settings = utils_1.ObjectUtils.assign(this._context.getFormatCodeSettings(), settings);
        utils_1.fillDefaultFormatCodeSettings(settings, this._context.manipulationSettings);
        settings["_filled"] = true;
        return settings;
    }
    _getFilledUserPreferences(userPreferences) {
        return utils_1.ObjectUtils.assign(this._context.getUserPreferences(), userPreferences);
    }
}
exports.LanguageService = LanguageService;
