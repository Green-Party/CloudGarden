"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../../utils");
const TextSpan_1 = require("./TextSpan");
/**
 * Document span.
 */
class DocumentSpan {
    /**
     * @private
     */
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
        // store this node so that it's start doesn't go out of date because of manipulation (though the text span may)
        // Note: this will cause the source file to transitively hold a reference to this node and so it won't be released
        // from the WeakMap until a manipulation happens on the source file.
        this._sourceFile = this._context.compilerFactory.getSourceFileFromCacheFromFilePath(this.compilerObject.fileName);
        this._sourceFile._doActionPreNextModification(() => this.getNode());
    }
    /**
     * Gets the compiler object.
     */
    get compilerObject() {
        return this._compilerObject;
    }
    /**
     * Gets the source file this reference is in.
     */
    getSourceFile() {
        return this._sourceFile;
    }
    /**
     * Gets the text span.
     */
    getTextSpan() {
        return new TextSpan_1.TextSpan(this.compilerObject.textSpan);
    }
    /**
     * Gets the node at the start of the text span.
     */
    getNode() {
        const textSpan = this.getTextSpan();
        const sourceFile = this.getSourceFile();
        const start = textSpan.getStart();
        const width = textSpan.getEnd();
        return findBestMatchingNode();
        function findBestMatchingNode() {
            // more relaxed getDescendantAtStartWithWidth because the position may be within a string literal
            let bestNode;
            sourceFile._context.compilerFactory.forgetNodesCreatedInBlock(remember => {
                let foundNode;
                let nextNode = sourceFile;
                while (nextNode != null) {
                    if (foundNode == null)
                        bestNode = nextNode;
                    if (nextNode.getStart() === start && nextNode.getWidth() === width)
                        bestNode = foundNode = nextNode;
                    else if (foundNode != null)
                        break; // no need to keep looking
                    nextNode = nextNode.getChildAtPos(start);
                }
                if (bestNode != null)
                    remember(bestNode);
            });
            return bestNode;
        }
    }
    /**
     * Gets the original text span if the span represents a location that was remapped.
     */
    getOriginalTextSpan() {
        const { originalTextSpan } = this.compilerObject;
        return originalTextSpan == null ? undefined : new TextSpan_1.TextSpan(originalTextSpan);
    }
    /**
     * Gets the original file name if the span represents a location that was remapped.
     */
    getOriginalFileName() {
        return this.compilerObject.originalFileName;
    }
}
__decorate([
    utils_1.Memoize
], DocumentSpan.prototype, "getTextSpan", null);
__decorate([
    utils_1.Memoize
], DocumentSpan.prototype, "getNode", null);
__decorate([
    utils_1.Memoize
], DocumentSpan.prototype, "getOriginalTextSpan", null);
exports.DocumentSpan = DocumentSpan;
