"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../errors");
const utils_1 = require("../../utils");
const Type_1 = require("./Type");
class TypeParameter extends Type_1.Type {
    /**
     * Gets the constraint or throws if it doesn't exist.
     */
    getConstraintOrThrow() {
        return errors.throwIfNullOrUndefined(this.getConstraint(), "Expected type parameter to have a constraint.");
    }
    /**
     * Gets the constraint type.
     */
    getConstraint() {
        const declaration = this._getTypeParameterDeclaration();
        if (declaration == null)
            return undefined;
        const constraintNode = declaration.getConstraint();
        if (constraintNode == null)
            return undefined;
        return this._context.typeChecker.getTypeAtLocation(constraintNode);
    }
    /**
     * Gets the default type or throws if it doesn't exist.
     */
    getDefaultOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDefault(), "Expected type parameter to have a default type.");
    }
    /**
     * Gets the default type or undefined if it doesn't exist.
     */
    getDefault() {
        const declaration = this._getTypeParameterDeclaration();
        if (declaration == null)
            return undefined;
        const defaultNode = declaration.getDefault();
        if (defaultNode == null)
            return undefined;
        return this._context.typeChecker.getTypeAtLocation(defaultNode);
    }
    /**
     * @internal
     */
    _getTypeParameterDeclaration() {
        const symbol = this.getSymbol();
        if (symbol == null)
            return undefined;
        const declaration = symbol.getDeclarations()[0];
        if (declaration == null)
            return undefined;
        if (!utils_1.TypeGuards.isTypeParameterDeclaration(declaration))
            return undefined;
        return declaration;
    }
}
exports.TypeParameter = TypeParameter;
