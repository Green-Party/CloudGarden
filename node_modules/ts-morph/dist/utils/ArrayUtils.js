"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ArrayUtils {
    constructor() {
    }
    static isReadonlyArray(a) {
        return a instanceof Array;
    }
    static isNullOrEmpty(a) {
        return !(a instanceof Array) || a.length === 0;
    }
    static getUniqueItems(a) {
        return a.filter((item, index) => a.indexOf(item) === index);
    }
    static removeFirst(a, item) {
        const index = a.indexOf(item);
        if (index === -1)
            return false;
        a.splice(index, 1);
        return true;
    }
    static removeAll(a, isMatch) {
        const removedItems = [];
        for (let i = a.length - 1; i >= 0; i--) {
            if (isMatch(a[i])) {
                removedItems.push(a[i]);
                a.splice(i, 1);
            }
        }
        return removedItems;
    }
    // can't use ReadonlyArray here for some reason
    static flatten(items) {
        return items.reduce((a, b) => a.concat(b), []);
    }
    static from(items) {
        const a = [];
        for (const item of items) // it will work
            a.push(item);
        return a;
    }
    static *toIterator(items) {
        for (const item of items) {
            yield item;
        }
    }
    static sortByProperty(items, getProp) {
        items.sort((a, b) => getProp(a) <= getProp(b) ? -1 : 1);
        return items;
    }
    static groupBy(items, getGroup) {
        const result = [];
        const groups = {};
        for (const item of items) {
            const group = getGroup(item).toString();
            if (groups[group] == null) {
                groups[group] = [];
                result.push(groups[group]);
            }
            groups[group].push(item);
        }
        return result;
    }
    static binaryInsertWithOverwrite(items, newItem, comparer) {
        let top = items.length - 1;
        let bottom = 0;
        while (bottom <= top) {
            const mid = Math.floor((top + bottom) / 2);
            if (comparer.compareTo(newItem, items[mid]) < 0)
                top = mid - 1;
            else
                bottom = mid + 1;
        }
        // overwrite an existing item
        if (items[top] != null && comparer.compareTo(newItem, items[top]) === 0)
            items[top] = newItem;
        else
            items.splice(top + 1, 0, newItem);
    }
    static binarySearch(items, storedComparer) {
        let top = items.length - 1;
        let bottom = 0;
        while (bottom <= top) {
            const mid = Math.floor((top + bottom) / 2);
            const comparisonResult = storedComparer.compareTo(items[mid]);
            if (comparisonResult === 0)
                return mid;
            else if (comparisonResult < 0)
                top = mid - 1;
            else
                bottom = mid + 1;
        }
        return -1;
    }
    static containsSubArray(items, subArray) {
        let findIndex = 0;
        for (const item of items) {
            if (subArray[findIndex] === item) {
                findIndex++;
                if (findIndex === subArray.length)
                    return true;
            }
            else
                findIndex = 0;
        }
        return false;
    }
}
exports.ArrayUtils = ArrayUtils;
