"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const collections_1 = require("../collections");
const compiler_1 = require("../compiler");
const TypeGuards_1 = require("../TypeGuards");
class SourceFileReferenceContainer {
    constructor(sourceFile) {
        this.sourceFile = sourceFile;
        this.nodesInThis = new collections_1.KeyValueCache();
        this.nodesInOther = new collections_1.KeyValueCache();
        this.unresolvedLiterals = [];
        this.resolveUnresolved = () => {
            for (let i = this.unresolvedLiterals.length - 1; i >= 0; i--) {
                const literal = this.unresolvedLiterals[i];
                const sourceFile = this.getSourceFileForLiteral(literal);
                if (sourceFile != null) {
                    this.unresolvedLiterals.splice(i, 1);
                    this.addNodeInThis(literal, sourceFile);
                }
            }
            if (this.unresolvedLiterals.length === 0)
                this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved, false);
        };
    }
    getDependentSourceFiles() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshDirtySourceFiles();
        const hashSet = new Set();
        for (const nodeInOther of this.nodesInOther.getKeys())
            hashSet.add(nodeInOther._sourceFile);
        return hashSet.values();
    }
    getLiteralsReferencingOtherSourceFilesEntries() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshSourceFileIfDirty(this.sourceFile);
        return this.nodesInThis.getEntries();
    }
    getReferencingLiteralsInOtherSourceFiles() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshDirtySourceFiles();
        return this.nodesInOther.getKeys();
    }
    *getReferencingNodesInOtherSourceFiles() {
        for (const literal of this.getReferencingLiteralsInOtherSourceFiles()) {
            const parent = literal.getParentOrThrow();
            const grandParent = parent.getParent();
            if (grandParent != null && TypeGuards_1.TypeGuards.isImportEqualsDeclaration(grandParent))
                yield grandParent;
            else
                yield literal.getParentOrThrow();
        }
    }
    refresh() {
        if (this.unresolvedLiterals.length > 0)
            this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved, false);
        this.clear();
        this.populateReferences();
        if (this.unresolvedLiterals.length > 0)
            this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved);
    }
    clear() {
        this.unresolvedLiterals.length = 0;
        for (const [node, sourceFile] of this.nodesInThis.getEntries()) {
            this.nodesInThis.removeByKey(node);
            sourceFile._referenceContainer.nodesInOther.removeByKey(node);
        }
    }
    populateReferences() {
        this.sourceFile._context.compilerFactory.forgetNodesCreatedInBlock(remember => {
            for (const literal of this.sourceFile.getImportStringLiterals()) {
                const sourceFile = this.getSourceFileForLiteral(literal);
                remember(literal);
                if (sourceFile == null)
                    this.unresolvedLiterals.push(literal);
                else
                    this.addNodeInThis(literal, sourceFile);
            }
        });
    }
    getSourceFileForLiteral(literal) {
        const parent = literal.getParentOrThrow();
        const grandParent = parent.getParent();
        if (TypeGuards_1.TypeGuards.isImportDeclaration(parent) || TypeGuards_1.TypeGuards.isExportDeclaration(parent))
            return parent.getModuleSpecifierSourceFile();
        else if (grandParent != null && TypeGuards_1.TypeGuards.isImportEqualsDeclaration(grandParent))
            return grandParent.getExternalModuleReferenceSourceFile();
        else if (TypeGuards_1.TypeGuards.isCallExpression(parent)) {
            const literalSymbol = literal.getSymbol();
            if (literalSymbol != null)
                return compiler_1.ModuleUtils.getReferencedSourceFileFromSymbol(literalSymbol);
        }
        else
            this.sourceFile._context.logger.warn(`Unknown import string literal parent: ${parent.getKindName()}`);
        return undefined;
    }
    addNodeInThis(literal, sourceFile) {
        this.nodesInThis.set(literal, sourceFile);
        sourceFile._referenceContainer.nodesInOther.set(literal, sourceFile);
    }
}
exports.SourceFileReferenceContainer = SourceFileReferenceContainer;
