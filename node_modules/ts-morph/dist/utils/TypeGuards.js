"use strict";
// -----------------------
// WARNING - DO NOT modify the "is" methods of the TypeGuards class directly. It is code generated by createTypeGuardsUtility.ts
//
// Note: This file is excluded from code coverage reports because it's automatically maintained (low risk).
// -----------------------
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
const compiler = require("../compiler");
const typescript_1 = require("../typescript");
/**
 * Type guards for checking the type of a node.
 */
class TypeGuards {
    constructor() {
    }
    /**
     * Gets if the node has an expression.
     * @param node - Node to check.
     */
    static hasExpression(node) {
        // this method is manually maintained
        if (node.getExpression == null)
            return false;
        return node.getExpression() != null;
    }
    /**
     * Gets if the node has a name.
     * @param node - Node to check.
     */
    static hasName(node) {
        // this method is manually maintained
        if (node.getName == null)
            return false;
        return typeof node.getName() === "string";
    }
    /**
     * Gets if the node has a body.
     * @param node - Node to check.
     */
    static hasBody(node) {
        // this method is manually maintained
        if (node.getBody == null)
            return false;
        return node.getBody() != null;
    }
    /**
     * Gets if the provided value is a Node.
     */
    static isNode(value) {
        return value != null && value.compilerNode != null;
    }
    /**
     * Gets if the provided value is a CommentStatement.
     */
    static isCommentStatement(node) {
        return node.compilerNode._commentKind === compiler.CommentNodeKind.Statement;
    }
    /**
     * Gets if the provided value is a CommentClassElement.
     */
    static isCommentClassElement(node) {
        return node.compilerNode._commentKind === compiler.CommentNodeKind.ClassElement;
    }
    /**
     * Gets if the provided value is a CommentTypeElement.
     */
    static isCommentTypeElement(node) {
        return node.compilerNode._commentKind === compiler.CommentNodeKind.TypeElement;
    }
    /**
     * Gets if the provided value is a CommentObjectLiteralElement.
     */
    static isCommentObjectLiteralElement(node) {
        return node.compilerNode._commentKind === compiler.CommentNodeKind.ObjectLiteralElement;
    }
    /**
     * Gets if the provided value is a CommentEnumMember.
     */
    static isCommentEnumMember(node) {
        return node.compilerNode._commentKind == compiler.CommentNodeKind.EnumMember;
    }
    /**
     * Gets if the node is an AbstractableNode.
     * @param node - Node to check.
     */
    static isAbstractableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an AmbientableNode.
     * @param node - Node to check.
     */
    static isAmbientableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an AnyKeyword.
     * @param node - Node to check.
     */
    static isAnyKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.AnyKeyword;
    }
    /**
     * Gets if the node is an ArgumentedNode.
     * @param node - Node to check.
     */
    static isArgumentedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.CallExpression:
            case typescript_1.SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an ArrayBindingPattern.
     * @param node - Node to check.
     */
    static isArrayBindingPattern(node) {
        return node.getKind() === typescript_1.SyntaxKind.ArrayBindingPattern;
    }
    /**
     * Gets if the node is an ArrayLiteralExpression.
     * @param node - Node to check.
     */
    static isArrayLiteralExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ArrayLiteralExpression;
    }
    /**
     * Gets if the node is an ArrayTypeNode.
     * @param node - Node to check.
     */
    static isArrayTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.ArrayType;
    }
    /**
     * Gets if the node is an ArrowFunction.
     * @param node - Node to check.
     */
    static isArrowFunction(node) {
        return node.getKind() === typescript_1.SyntaxKind.ArrowFunction;
    }
    /**
     * Gets if the node is an AsExpression.
     * @param node - Node to check.
     */
    static isAsExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.AsExpression;
    }
    /**
     * Gets if the node is an AsyncableNode.
     * @param node - Node to check.
     */
    static isAsyncableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an AwaitExpression.
     * @param node - Node to check.
     */
    static isAwaitExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.AwaitExpression;
    }
    /**
     * Gets if the node is an AwaitableNode.
     * @param node - Node to check.
     */
    static isAwaitableNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.ForOfStatement;
    }
    /**
     * Gets if the node is a BinaryExpression.
     * @param node - Node to check.
     */
    static isBinaryExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.BinaryExpression;
    }
    /**
     * Gets if the node is a BindingElement.
     * @param node - Node to check.
     */
    static isBindingElement(node) {
        return node.getKind() === typescript_1.SyntaxKind.BindingElement;
    }
    /**
     * Gets if the node is a BindingNamedNode.
     * @param node - Node to check.
     */
    static isBindingNamedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.BindingElement:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a Block.
     * @param node - Node to check.
     */
    static isBlock(node) {
        return node.getKind() === typescript_1.SyntaxKind.Block;
    }
    /**
     * Gets if the node is a BodiedNode.
     * @param node - Node to check.
     */
    static isBodiedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a BodyableNode.
     * @param node - Node to check.
     */
    static isBodyableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a BooleanKeyword.
     * @param node - Node to check.
     */
    static isBooleanKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.BooleanKeyword;
    }
    /**
     * Gets if the node is a BooleanLiteral.
     * @param node - Node to check.
     */
    static isBooleanLiteral(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.FalseKeyword:
            case typescript_1.SyntaxKind.TrueKeyword:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a BreakStatement.
     * @param node - Node to check.
     */
    static isBreakStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.BreakStatement;
    }
    /**
     * Gets if the node is a CallExpression.
     * @param node - Node to check.
     */
    static isCallExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.CallExpression;
    }
    /**
     * Gets if the node is a CallSignatureDeclaration.
     * @param node - Node to check.
     */
    static isCallSignatureDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.CallSignature;
    }
    /**
     * Gets if the node is a CaseBlock.
     * @param node - Node to check.
     */
    static isCaseBlock(node) {
        return node.getKind() === typescript_1.SyntaxKind.CaseBlock;
    }
    /**
     * Gets if the node is a CaseClause.
     * @param node - Node to check.
     */
    static isCaseClause(node) {
        return node.getKind() === typescript_1.SyntaxKind.CaseClause;
    }
    /**
     * Gets if the node is a CatchClause.
     * @param node - Node to check.
     */
    static isCatchClause(node) {
        return node.getKind() === typescript_1.SyntaxKind.CatchClause;
    }
    /**
     * Gets if the node is a ChildOrderableNode.
     * @param node - Node to check.
     */
    static isChildOrderableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.IndexSignature:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.ExportAssignment:
            case typescript_1.SyntaxKind.ExportDeclaration:
            case typescript_1.SyntaxKind.ImportDeclaration:
            case typescript_1.SyntaxKind.ImportEqualsDeclaration:
            case typescript_1.SyntaxKind.ModuleBlock:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.Block:
            case typescript_1.SyntaxKind.BreakStatement:
            case typescript_1.SyntaxKind.ContinueStatement:
            case typescript_1.SyntaxKind.DebuggerStatement:
            case typescript_1.SyntaxKind.DoStatement:
            case typescript_1.SyntaxKind.EmptyStatement:
            case typescript_1.SyntaxKind.ExpressionStatement:
            case typescript_1.SyntaxKind.ForInStatement:
            case typescript_1.SyntaxKind.ForOfStatement:
            case typescript_1.SyntaxKind.ForStatement:
            case typescript_1.SyntaxKind.IfStatement:
            case typescript_1.SyntaxKind.LabeledStatement:
            case typescript_1.SyntaxKind.NotEmittedStatement:
            case typescript_1.SyntaxKind.ReturnStatement:
            case typescript_1.SyntaxKind.SwitchStatement:
            case typescript_1.SyntaxKind.ThrowStatement:
            case typescript_1.SyntaxKind.TryStatement:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.WhileStatement:
            case typescript_1.SyntaxKind.WithStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ClassDeclaration.
     * @param node - Node to check.
     */
    static isClassDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.ClassDeclaration;
    }
    /**
     * Gets if the node is a ClassExpression.
     * @param node - Node to check.
     */
    static isClassExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ClassExpression;
    }
    /**
     * Gets if the node is a ClassLikeDeclarationBase.
     * @param node - Node to check.
     */
    static isClassLikeDeclarationBase(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a CommaListExpression.
     * @param node - Node to check.
     */
    static isCommaListExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.CommaListExpression;
    }
    /**
     * Gets if the node is a ComputedPropertyName.
     * @param node - Node to check.
     */
    static isComputedPropertyName(node) {
        return node.getKind() === typescript_1.SyntaxKind.ComputedPropertyName;
    }
    /**
     * Gets if the node is a ConditionalExpression.
     * @param node - Node to check.
     */
    static isConditionalExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ConditionalExpression;
    }
    /**
     * Gets if the node is a ConditionalTypeNode.
     * @param node - Node to check.
     */
    static isConditionalTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.ConditionalType;
    }
    /**
     * Gets if the node is a ConstructSignatureDeclaration.
     * @param node - Node to check.
     */
    static isConstructSignatureDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.ConstructSignature;
    }
    /**
     * Gets if the node is a ConstructorDeclaration.
     * @param node - Node to check.
     */
    static isConstructorDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.Constructor;
    }
    /**
     * Gets if the node is a ConstructorTypeNode.
     * @param node - Node to check.
     */
    static isConstructorTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.ConstructorType;
    }
    /**
     * Gets if the node is a ContinueStatement.
     * @param node - Node to check.
     */
    static isContinueStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.ContinueStatement;
    }
    /**
     * Gets if the node is a DebuggerStatement.
     * @param node - Node to check.
     */
    static isDebuggerStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.DebuggerStatement;
    }
    /**
     * Gets if the node is a DecoratableNode.
     * @param node - Node to check.
     */
    static isDecoratableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a Decorator.
     * @param node - Node to check.
     */
    static isDecorator(node) {
        return node.getKind() === typescript_1.SyntaxKind.Decorator;
    }
    /**
     * Gets if the node is a DefaultClause.
     * @param node - Node to check.
     */
    static isDefaultClause(node) {
        return node.getKind() === typescript_1.SyntaxKind.DefaultClause;
    }
    /**
     * Gets if the node is a DeleteExpression.
     * @param node - Node to check.
     */
    static isDeleteExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.DeleteExpression;
    }
    /**
     * Gets if the node is a DoStatement.
     * @param node - Node to check.
     */
    static isDoStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.DoStatement;
    }
    /**
     * Gets if the node is an ElementAccessExpression.
     * @param node - Node to check.
     */
    static isElementAccessExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ElementAccessExpression;
    }
    /**
     * Gets if the node is an EmptyStatement.
     * @param node - Node to check.
     */
    static isEmptyStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.EmptyStatement;
    }
    /**
     * Gets if the node is an EnumDeclaration.
     * @param node - Node to check.
     */
    static isEnumDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.EnumDeclaration;
    }
    /**
     * Gets if the node is an EnumMember.
     * @param node - Node to check.
     */
    static isEnumMember(node) {
        return node.getKind() === typescript_1.SyntaxKind.EnumMember;
    }
    /**
     * Gets if the node is an ExclamationTokenableNode.
     * @param node - Node to check.
     */
    static isExclamationTokenableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an ExportAssignment.
     * @param node - Node to check.
     */
    static isExportAssignment(node) {
        return node.getKind() === typescript_1.SyntaxKind.ExportAssignment;
    }
    /**
     * Gets if the node is an ExportDeclaration.
     * @param node - Node to check.
     */
    static isExportDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.ExportDeclaration;
    }
    /**
     * Gets if the node is an ExportGetableNode.
     * @param node - Node to check.
     */
    static isExportGetableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
            case typescript_1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an ExportSpecifier.
     * @param node - Node to check.
     */
    static isExportSpecifier(node) {
        return node.getKind() === typescript_1.SyntaxKind.ExportSpecifier;
    }
    /**
     * Gets if the node is an ExportableNode.
     * @param node - Node to check.
     */
    static isExportableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an Expression.
     * @param node - Node to check.
     */
    static isExpression(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.AnyKeyword:
            case typescript_1.SyntaxKind.BooleanKeyword:
            case typescript_1.SyntaxKind.NeverKeyword:
            case typescript_1.SyntaxKind.NumberKeyword:
            case typescript_1.SyntaxKind.ObjectKeyword:
            case typescript_1.SyntaxKind.StringKeyword:
            case typescript_1.SyntaxKind.SymbolKeyword:
            case typescript_1.SyntaxKind.UndefinedKeyword:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.AsExpression:
            case typescript_1.SyntaxKind.AwaitExpression:
            case typescript_1.SyntaxKind.BinaryExpression:
            case typescript_1.SyntaxKind.CallExpression:
            case typescript_1.SyntaxKind.CommaListExpression:
            case typescript_1.SyntaxKind.ConditionalExpression:
            case typescript_1.SyntaxKind.DeleteExpression:
            case typescript_1.SyntaxKind.ElementAccessExpression:
            case typescript_1.SyntaxKind.ImportKeyword:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.NonNullExpression:
            case typescript_1.SyntaxKind.OmittedExpression:
            case typescript_1.SyntaxKind.ParenthesizedExpression:
            case typescript_1.SyntaxKind.PartiallyEmittedExpression:
            case typescript_1.SyntaxKind.PostfixUnaryExpression:
            case typescript_1.SyntaxKind.PrefixUnaryExpression:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.SpreadElement:
            case typescript_1.SyntaxKind.SuperKeyword:
            case typescript_1.SyntaxKind.ThisKeyword:
            case typescript_1.SyntaxKind.TypeAssertionExpression:
            case typescript_1.SyntaxKind.TypeOfExpression:
            case typescript_1.SyntaxKind.VoidExpression:
            case typescript_1.SyntaxKind.YieldExpression:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.JsxClosingFragment:
            case typescript_1.SyntaxKind.JsxElement:
            case typescript_1.SyntaxKind.JsxExpression:
            case typescript_1.SyntaxKind.JsxFragment:
            case typescript_1.SyntaxKind.JsxOpeningElement:
            case typescript_1.SyntaxKind.JsxOpeningFragment:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
            case typescript_1.SyntaxKind.FalseKeyword:
            case typescript_1.SyntaxKind.TrueKeyword:
            case typescript_1.SyntaxKind.NullKeyword:
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.ArrayLiteralExpression:
            case typescript_1.SyntaxKind.ObjectLiteralExpression:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case typescript_1.SyntaxKind.TaggedTemplateExpression:
            case typescript_1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an ExpressionStatement.
     * @param node - Node to check.
     */
    static isExpressionStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.ExpressionStatement;
    }
    /**
     * Gets if the node is an ExpressionWithTypeArguments.
     * @param node - Node to check.
     */
    static isExpressionWithTypeArguments(node) {
        return node.getKind() === typescript_1.SyntaxKind.ExpressionWithTypeArguments;
    }
    /**
     * Gets if the node is an ExpressionedNode.
     * @param node - Node to check.
     */
    static isExpressionedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.AsExpression:
            case typescript_1.SyntaxKind.NonNullExpression:
            case typescript_1.SyntaxKind.ParenthesizedExpression:
            case typescript_1.SyntaxKind.PartiallyEmittedExpression:
            case typescript_1.SyntaxKind.SpreadElement:
            case typescript_1.SyntaxKind.SpreadAssignment:
            case typescript_1.SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is an ExtendsClauseableNode.
     * @param node - Node to check.
     */
    static isExtendsClauseableNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.InterfaceDeclaration;
    }
    /**
     * Gets if the node is an ExternalModuleReference.
     * @param node - Node to check.
     */
    static isExternalModuleReference(node) {
        return node.getKind() === typescript_1.SyntaxKind.ExternalModuleReference;
    }
    /**
     * Gets if the node is a FalseKeyword.
     * @param node - Node to check.
     */
    static isFalseKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.FalseKeyword;
    }
    /**
     * Gets if the node is a ForInStatement.
     * @param node - Node to check.
     */
    static isForInStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.ForInStatement;
    }
    /**
     * Gets if the node is a ForOfStatement.
     * @param node - Node to check.
     */
    static isForOfStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.ForOfStatement;
    }
    /**
     * Gets if the node is a ForStatement.
     * @param node - Node to check.
     */
    static isForStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.ForStatement;
    }
    /**
     * Gets if the node is a FunctionDeclaration.
     * @param node - Node to check.
     */
    static isFunctionDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.FunctionDeclaration;
    }
    /**
     * Gets if the node is a FunctionExpression.
     * @param node - Node to check.
     */
    static isFunctionExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.FunctionExpression;
    }
    /**
     * Gets if the node is a FunctionLikeDeclaration.
     * @param node - Node to check.
     */
    static isFunctionLikeDeclaration(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a FunctionTypeNode.
     * @param node - Node to check.
     */
    static isFunctionTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.FunctionType;
    }
    /**
     * Gets if the node is a GeneratorableNode.
     * @param node - Node to check.
     */
    static isGeneratorableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.YieldExpression:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a GetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isGetAccessorDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.GetAccessor;
    }
    /**
     * Gets if the node is a HeritageClause.
     * @param node - Node to check.
     */
    static isHeritageClause(node) {
        return node.getKind() === typescript_1.SyntaxKind.HeritageClause;
    }
    /**
     * Gets if the node is a HeritageClauseableNode.
     * @param node - Node to check.
     */
    static isHeritageClauseableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a Identifier.
     * @param node - Node to check.
     */
    static isIdentifier(node) {
        return node.getKind() === typescript_1.SyntaxKind.Identifier;
    }
    /**
     * Gets if the node is a IfStatement.
     * @param node - Node to check.
     */
    static isIfStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.IfStatement;
    }
    /**
     * Gets if the node is a ImplementsClauseableNode.
     * @param node - Node to check.
     */
    static isImplementsClauseableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ImportClause.
     * @param node - Node to check.
     */
    static isImportClause(node) {
        return node.getKind() === typescript_1.SyntaxKind.ImportClause;
    }
    /**
     * Gets if the node is a ImportDeclaration.
     * @param node - Node to check.
     */
    static isImportDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.ImportDeclaration;
    }
    /**
     * Gets if the node is a ImportEqualsDeclaration.
     * @param node - Node to check.
     */
    static isImportEqualsDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.ImportEqualsDeclaration;
    }
    /**
     * Gets if the node is a ImportExpression.
     * @param node - Node to check.
     */
    static isImportExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ImportKeyword;
    }
    /**
     * Gets if the node is a ImportSpecifier.
     * @param node - Node to check.
     */
    static isImportSpecifier(node) {
        return node.getKind() === typescript_1.SyntaxKind.ImportSpecifier;
    }
    /**
     * Gets if the node is a ImportTypeNode.
     * @param node - Node to check.
     */
    static isImportTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.ImportType;
    }
    /**
     * Gets if the node is a IndexSignatureDeclaration.
     * @param node - Node to check.
     */
    static isIndexSignatureDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.IndexSignature;
    }
    /**
     * Gets if the node is a IndexedAccessTypeNode.
     * @param node - Node to check.
     */
    static isIndexedAccessTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.IndexedAccessType;
    }
    /**
     * Gets if the node is a InferKeyword.
     * @param node - Node to check.
     */
    static isInferKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.InferKeyword;
    }
    /**
     * Gets if the node is a InferTypeNode.
     * @param node - Node to check.
     */
    static isInferTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.InferType;
    }
    /**
     * Gets if the node is a InitializerExpressionGetableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionGetableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.BindingElement:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.EnumMember:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.VariableDeclaration:
            case typescript_1.SyntaxKind.PropertyAssignment:
            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a InitializerExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.BindingElement:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.EnumMember:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a InterfaceDeclaration.
     * @param node - Node to check.
     */
    static isInterfaceDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.InterfaceDeclaration;
    }
    /**
     * Gets if the node is a IntersectionTypeNode.
     * @param node - Node to check.
     */
    static isIntersectionTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.IntersectionType;
    }
    /**
     * Gets if the node is a IterationStatement.
     * @param node - Node to check.
     */
    static isIterationStatement(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.DoStatement:
            case typescript_1.SyntaxKind.ForInStatement:
            case typescript_1.SyntaxKind.ForOfStatement:
            case typescript_1.SyntaxKind.ForStatement:
            case typescript_1.SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a JSDoc.
     * @param node - Node to check.
     */
    static isJSDoc(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocComment;
    }
    /**
     * Gets if the node is a JSDocAugmentsTag.
     * @param node - Node to check.
     */
    static isJSDocAugmentsTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocAugmentsTag;
    }
    /**
     * Gets if the node is a JSDocClassTag.
     * @param node - Node to check.
     */
    static isJSDocClassTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocClassTag;
    }
    /**
     * Gets if the node is a JSDocFunctionType.
     * @param node - Node to check.
     */
    static isJSDocFunctionType(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocFunctionType;
    }
    /**
     * Gets if the node is a JSDocParameterTag.
     * @param node - Node to check.
     */
    static isJSDocParameterTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocParameterTag;
    }
    /**
     * Gets if the node is a JSDocPropertyLikeTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyLikeTag(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.JSDocParameterTag:
            case typescript_1.SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a JSDocPropertyTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocPropertyTag;
    }
    /**
     * Gets if the node is a JSDocReturnTag.
     * @param node - Node to check.
     */
    static isJSDocReturnTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocReturnTag;
    }
    /**
     * Gets if the node is a JSDocSignature.
     * @param node - Node to check.
     */
    static isJSDocSignature(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocSignature;
    }
    /**
     * Gets if the node is a JSDocTag.
     * @param node - Node to check.
     */
    static isJSDocTag(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.JSDocAugmentsTag:
            case typescript_1.SyntaxKind.JSDocClassTag:
            case typescript_1.SyntaxKind.JSDocParameterTag:
            case typescript_1.SyntaxKind.JSDocPropertyTag:
            case typescript_1.SyntaxKind.JSDocReturnTag:
            case typescript_1.SyntaxKind.JSDocTypedefTag:
            case typescript_1.SyntaxKind.JSDocTypeTag:
            case typescript_1.SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a JSDocType.
     * @param node - Node to check.
     */
    static isJSDocType(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.JSDocFunctionType:
            case typescript_1.SyntaxKind.JSDocSignature:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a JSDocTypeExpression.
     * @param node - Node to check.
     */
    static isJSDocTypeExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocTypeExpression;
    }
    /**
     * Gets if the node is a JSDocTypeTag.
     * @param node - Node to check.
     */
    static isJSDocTypeTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocTypeTag;
    }
    /**
     * Gets if the node is a JSDocTypedefTag.
     * @param node - Node to check.
     */
    static isJSDocTypedefTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocTypedefTag;
    }
    /**
     * Gets if the node is a JSDocUnknownTag.
     * @param node - Node to check.
     */
    static isJSDocUnknownTag(node) {
        return node.getKind() === typescript_1.SyntaxKind.JSDocTag;
    }
    /**
     * Gets if the node is a JSDocableNode.
     * @param node - Node to check.
     */
    static isJSDocableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.EnumMember:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.IndexSignature:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.ImportEqualsDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.ExpressionStatement:
            case typescript_1.SyntaxKind.LabeledStatement:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a JsxAttribute.
     * @param node - Node to check.
     */
    static isJsxAttribute(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxAttribute;
    }
    /**
     * Gets if the node is a JsxAttributedNode.
     * @param node - Node to check.
     */
    static isJsxAttributedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.JsxOpeningElement:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a JsxClosingElement.
     * @param node - Node to check.
     */
    static isJsxClosingElement(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxClosingElement;
    }
    /**
     * Gets if the node is a JsxClosingFragment.
     * @param node - Node to check.
     */
    static isJsxClosingFragment(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxClosingFragment;
    }
    /**
     * Gets if the node is a JsxElement.
     * @param node - Node to check.
     */
    static isJsxElement(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxElement;
    }
    /**
     * Gets if the node is a JsxExpression.
     * @param node - Node to check.
     */
    static isJsxExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxExpression;
    }
    /**
     * Gets if the node is a JsxFragment.
     * @param node - Node to check.
     */
    static isJsxFragment(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxFragment;
    }
    /**
     * Gets if the node is a JsxOpeningElement.
     * @param node - Node to check.
     */
    static isJsxOpeningElement(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxOpeningElement;
    }
    /**
     * Gets if the node is a JsxOpeningFragment.
     * @param node - Node to check.
     */
    static isJsxOpeningFragment(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxOpeningFragment;
    }
    /**
     * Gets if the node is a JsxSelfClosingElement.
     * @param node - Node to check.
     */
    static isJsxSelfClosingElement(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxSelfClosingElement;
    }
    /**
     * Gets if the node is a JsxSpreadAttribute.
     * @param node - Node to check.
     */
    static isJsxSpreadAttribute(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxSpreadAttribute;
    }
    /**
     * Gets if the node is a JsxTagNamedNode.
     * @param node - Node to check.
     */
    static isJsxTagNamedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.JsxClosingElement:
            case typescript_1.SyntaxKind.JsxOpeningElement:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a JsxText.
     * @param node - Node to check.
     */
    static isJsxText(node) {
        return node.getKind() === typescript_1.SyntaxKind.JsxText;
    }
    /**
     * Gets if the node is a LabeledStatement.
     * @param node - Node to check.
     */
    static isLabeledStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.LabeledStatement;
    }
    /**
     * Gets if the node is a LeftHandSideExpression.
     * @param node - Node to check.
     */
    static isLeftHandSideExpression(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.CallExpression:
            case typescript_1.SyntaxKind.ElementAccessExpression:
            case typescript_1.SyntaxKind.ImportKeyword:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.NonNullExpression:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.SuperKeyword:
            case typescript_1.SyntaxKind.ThisKeyword:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.JsxElement:
            case typescript_1.SyntaxKind.JsxFragment:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
            case typescript_1.SyntaxKind.FalseKeyword:
            case typescript_1.SyntaxKind.TrueKeyword:
            case typescript_1.SyntaxKind.NullKeyword:
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.ArrayLiteralExpression:
            case typescript_1.SyntaxKind.ObjectLiteralExpression:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case typescript_1.SyntaxKind.TaggedTemplateExpression:
            case typescript_1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a LeftHandSideExpressionedNode.
     * @param node - Node to check.
     */
    static isLeftHandSideExpressionedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.CallExpression:
            case typescript_1.SyntaxKind.ElementAccessExpression:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a LiteralExpression.
     * @param node - Node to check.
     */
    static isLiteralExpression(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a LiteralLikeNode.
     * @param node - Node to check.
     */
    static isLiteralLikeNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.JsxText:
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case typescript_1.SyntaxKind.TemplateHead:
            case typescript_1.SyntaxKind.TemplateMiddle:
            case typescript_1.SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a LiteralTypeNode.
     * @param node - Node to check.
     */
    static isLiteralTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.LiteralType;
    }
    /**
     * Gets if the node is a MemberExpression.
     * @param node - Node to check.
     */
    static isMemberExpression(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.ElementAccessExpression:
            case typescript_1.SyntaxKind.ImportKeyword:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.SuperKeyword:
            case typescript_1.SyntaxKind.ThisKeyword:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.JsxElement:
            case typescript_1.SyntaxKind.JsxFragment:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
            case typescript_1.SyntaxKind.FalseKeyword:
            case typescript_1.SyntaxKind.TrueKeyword:
            case typescript_1.SyntaxKind.NullKeyword:
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.ArrayLiteralExpression:
            case typescript_1.SyntaxKind.ObjectLiteralExpression:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case typescript_1.SyntaxKind.TaggedTemplateExpression:
            case typescript_1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a MetaProperty.
     * @param node - Node to check.
     */
    static isMetaProperty(node) {
        return node.getKind() === typescript_1.SyntaxKind.MetaProperty;
    }
    /**
     * Gets if the node is a MethodDeclaration.
     * @param node - Node to check.
     */
    static isMethodDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.MethodDeclaration;
    }
    /**
     * Gets if the node is a MethodSignature.
     * @param node - Node to check.
     */
    static isMethodSignature(node) {
        return node.getKind() === typescript_1.SyntaxKind.MethodSignature;
    }
    /**
     * Gets if the node is a ModifierableNode.
     * @param node - Node to check.
     */
    static isModifierableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.IndexSignature:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
            case typescript_1.SyntaxKind.VariableDeclarationList:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ModuleBlock.
     * @param node - Node to check.
     */
    static isModuleBlock(node) {
        return node.getKind() === typescript_1.SyntaxKind.ModuleBlock;
    }
    /**
     * Gets if the node is a ModuledNode.
     * @param node - Node to check.
     */
    static isModuledNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a NameableNode.
     * @param node - Node to check.
     */
    static isNameableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a NamedExports.
     * @param node - Node to check.
     */
    static isNamedExports(node) {
        return node.getKind() === typescript_1.SyntaxKind.NamedExports;
    }
    /**
     * Gets if the node is a NamedImports.
     * @param node - Node to check.
     */
    static isNamedImports(node) {
        return node.getKind() === typescript_1.SyntaxKind.NamedImports;
    }
    /**
     * Gets if the node is a NamedNode.
     * @param node - Node to check.
     */
    static isNamedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.JsxAttribute:
            case typescript_1.SyntaxKind.ImportEqualsDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
            case typescript_1.SyntaxKind.TypeParameter:
            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a NamespaceChildableNode.
     * @param node - Node to check.
     */
    static isNamespaceChildableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a NamespaceDeclaration.
     * @param node - Node to check.
     */
    static isNamespaceDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.ModuleDeclaration;
    }
    /**
     * Gets if the node is a NamespaceImport.
     * @param node - Node to check.
     */
    static isNamespaceImport(node) {
        return node.getKind() === typescript_1.SyntaxKind.NamespaceImport;
    }
    /**
     * Gets if the node is a NeverKeyword.
     * @param node - Node to check.
     */
    static isNeverKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.NeverKeyword;
    }
    /**
     * Gets if the node is a NewExpression.
     * @param node - Node to check.
     */
    static isNewExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.NewExpression;
    }
    /**
     * Gets if the node is a NoSubstitutionTemplateLiteral.
     * @param node - Node to check.
     */
    static isNoSubstitutionTemplateLiteral(node) {
        return node.getKind() === typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral;
    }
    /**
     * Gets if the node is a NonNullExpression.
     * @param node - Node to check.
     */
    static isNonNullExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.NonNullExpression;
    }
    /**
     * Gets if the node is a NotEmittedStatement.
     * @param node - Node to check.
     */
    static isNotEmittedStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.NotEmittedStatement;
    }
    /**
     * Gets if the node is a NullLiteral.
     * @param node - Node to check.
     */
    static isNullLiteral(node) {
        return node.getKind() === typescript_1.SyntaxKind.NullKeyword;
    }
    /**
     * Gets if the node is a NumberKeyword.
     * @param node - Node to check.
     */
    static isNumberKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.NumberKeyword;
    }
    /**
     * Gets if the node is a NumericLiteral.
     * @param node - Node to check.
     */
    static isNumericLiteral(node) {
        return node.getKind() === typescript_1.SyntaxKind.NumericLiteral;
    }
    /**
     * Gets if the node is a ObjectBindingPattern.
     * @param node - Node to check.
     */
    static isObjectBindingPattern(node) {
        return node.getKind() === typescript_1.SyntaxKind.ObjectBindingPattern;
    }
    /**
     * Gets if the node is a ObjectKeyword.
     * @param node - Node to check.
     */
    static isObjectKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.ObjectKeyword;
    }
    /**
     * Gets if the node is a ObjectLiteralExpression.
     * @param node - Node to check.
     */
    static isObjectLiteralExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ObjectLiteralExpression;
    }
    /**
     * Gets if the node is a OmittedExpression.
     * @param node - Node to check.
     */
    static isOmittedExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.OmittedExpression;
    }
    /**
     * Gets if the node is a OverloadableNode.
     * @param node - Node to check.
     */
    static isOverloadableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ParameterDeclaration.
     * @param node - Node to check.
     */
    static isParameterDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.Parameter;
    }
    /**
     * Gets if the node is a ParameteredNode.
     * @param node - Node to check.
     */
    static isParameteredNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.JSDocFunctionType:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.ConstructorType:
            case typescript_1.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ParenthesizedExpression.
     * @param node - Node to check.
     */
    static isParenthesizedExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ParenthesizedExpression;
    }
    /**
     * Gets if the node is a ParenthesizedTypeNode.
     * @param node - Node to check.
     */
    static isParenthesizedTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.ParenthesizedType;
    }
    /**
     * Gets if the node is a PartiallyEmittedExpression.
     * @param node - Node to check.
     */
    static isPartiallyEmittedExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.PartiallyEmittedExpression;
    }
    /**
     * Gets if the node is a PostfixUnaryExpression.
     * @param node - Node to check.
     */
    static isPostfixUnaryExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.PostfixUnaryExpression;
    }
    /**
     * Gets if the node is a PrefixUnaryExpression.
     * @param node - Node to check.
     */
    static isPrefixUnaryExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.PrefixUnaryExpression;
    }
    /**
     * Gets if the node is a PrimaryExpression.
     * @param node - Node to check.
     */
    static isPrimaryExpression(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.ImportKeyword:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.SuperKeyword:
            case typescript_1.SyntaxKind.ThisKeyword:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.JsxElement:
            case typescript_1.SyntaxKind.JsxFragment:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
            case typescript_1.SyntaxKind.FalseKeyword:
            case typescript_1.SyntaxKind.TrueKeyword:
            case typescript_1.SyntaxKind.NullKeyword:
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.ArrayLiteralExpression:
            case typescript_1.SyntaxKind.ObjectLiteralExpression:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case typescript_1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a PropertyAccessExpression.
     * @param node - Node to check.
     */
    static isPropertyAccessExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.PropertyAccessExpression;
    }
    /**
     * Gets if the node is a PropertyAssignment.
     * @param node - Node to check.
     */
    static isPropertyAssignment(node) {
        return node.getKind() === typescript_1.SyntaxKind.PropertyAssignment;
    }
    /**
     * Gets if the node is a PropertyDeclaration.
     * @param node - Node to check.
     */
    static isPropertyDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.PropertyDeclaration;
    }
    /**
     * Gets if the node is a PropertyNamedNode.
     * @param node - Node to check.
     */
    static isPropertyNamedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.EnumMember:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a PropertySignature.
     * @param node - Node to check.
     */
    static isPropertySignature(node) {
        return node.getKind() === typescript_1.SyntaxKind.PropertySignature;
    }
    /**
     * Gets if the node is a QualifiedName.
     * @param node - Node to check.
     */
    static isQualifiedName(node) {
        return node.getKind() === typescript_1.SyntaxKind.QualifiedName;
    }
    /**
     * Gets if the node is a QuestionTokenableNode.
     * @param node - Node to check.
     */
    static isQuestionTokenableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.PropertyAssignment:
            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ReadonlyableNode.
     * @param node - Node to check.
     */
    static isReadonlyableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.IndexSignature:
            case typescript_1.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ReferenceFindableNode.
     * @param node - Node to check.
     */
    static isReferenceFindableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.BindingElement:
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.EnumMember:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.JsxAttribute:
            case typescript_1.SyntaxKind.ImportEqualsDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
            case typescript_1.SyntaxKind.TypeParameter:
            case typescript_1.SyntaxKind.VariableDeclaration:
            case typescript_1.SyntaxKind.PropertyAssignment:
            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a RegularExpressionLiteral.
     * @param node - Node to check.
     */
    static isRegularExpressionLiteral(node) {
        return node.getKind() === typescript_1.SyntaxKind.RegularExpressionLiteral;
    }
    /**
     * Gets if the node is a RenameableNode.
     * @param node - Node to check.
     */
    static isRenameableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.BindingElement:
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.EnumMember:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.JsxAttribute:
            case typescript_1.SyntaxKind.ImportEqualsDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.NamespaceImport:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
            case typescript_1.SyntaxKind.TypeParameter:
            case typescript_1.SyntaxKind.VariableDeclaration:
            case typescript_1.SyntaxKind.PropertyAssignment:
            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ReturnStatement.
     * @param node - Node to check.
     */
    static isReturnStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.ReturnStatement;
    }
    /**
     * Gets if the node is a ReturnTypedNode.
     * @param node - Node to check.
     */
    static isReturnTypedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.JSDocFunctionType:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.IndexSignature:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.ConstructorType:
            case typescript_1.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ScopeableNode.
     * @param node - Node to check.
     */
    static isScopeableNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.Parameter;
    }
    /**
     * Gets if the node is a ScopedNode.
     * @param node - Node to check.
     */
    static isScopedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a SemicolonToken.
     * @param node - Node to check.
     */
    static isSemicolonToken(node) {
        return node.getKind() === typescript_1.SyntaxKind.SemicolonToken;
    }
    /**
     * Gets if the node is a SetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isSetAccessorDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.SetAccessor;
    }
    /**
     * Gets if the node is a ShorthandPropertyAssignment.
     * @param node - Node to check.
     */
    static isShorthandPropertyAssignment(node) {
        return node.getKind() === typescript_1.SyntaxKind.ShorthandPropertyAssignment;
    }
    /**
     * Gets if the node is a SignaturedDeclaration.
     * @param node - Node to check.
     */
    static isSignaturedDeclaration(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.JSDocFunctionType:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.ConstructorType:
            case typescript_1.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a SourceFile.
     * @param node - Node to check.
     */
    static isSourceFile(node) {
        return node.getKind() === typescript_1.SyntaxKind.SourceFile;
    }
    /**
     * Gets if the node is a SpreadAssignment.
     * @param node - Node to check.
     */
    static isSpreadAssignment(node) {
        return node.getKind() === typescript_1.SyntaxKind.SpreadAssignment;
    }
    /**
     * Gets if the node is a SpreadElement.
     * @param node - Node to check.
     */
    static isSpreadElement(node) {
        return node.getKind() === typescript_1.SyntaxKind.SpreadElement;
    }
    /**
     * Gets if the node is a Statement.
     * @param node - Node to check.
     */
    static isStatement(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.ExportAssignment:
            case typescript_1.SyntaxKind.ExportDeclaration:
            case typescript_1.SyntaxKind.ImportDeclaration:
            case typescript_1.SyntaxKind.ImportEqualsDeclaration:
            case typescript_1.SyntaxKind.ModuleBlock:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.Block:
            case typescript_1.SyntaxKind.BreakStatement:
            case typescript_1.SyntaxKind.ContinueStatement:
            case typescript_1.SyntaxKind.DebuggerStatement:
            case typescript_1.SyntaxKind.DoStatement:
            case typescript_1.SyntaxKind.EmptyStatement:
            case typescript_1.SyntaxKind.ExpressionStatement:
            case typescript_1.SyntaxKind.ForInStatement:
            case typescript_1.SyntaxKind.ForOfStatement:
            case typescript_1.SyntaxKind.ForStatement:
            case typescript_1.SyntaxKind.IfStatement:
            case typescript_1.SyntaxKind.LabeledStatement:
            case typescript_1.SyntaxKind.NotEmittedStatement:
            case typescript_1.SyntaxKind.ReturnStatement:
            case typescript_1.SyntaxKind.SwitchStatement:
            case typescript_1.SyntaxKind.ThrowStatement:
            case typescript_1.SyntaxKind.TryStatement:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.WhileStatement:
            case typescript_1.SyntaxKind.WithStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a StatementedNode.
     * @param node - Node to check.
     */
    static isStatementedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.ModuleBlock:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.SourceFile:
            case typescript_1.SyntaxKind.Block:
            case typescript_1.SyntaxKind.CaseClause:
            case typescript_1.SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a StaticableNode.
     * @param node - Node to check.
     */
    static isStaticableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a StringKeyword.
     * @param node - Node to check.
     */
    static isStringKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.StringKeyword;
    }
    /**
     * Gets if the node is a StringLiteral.
     * @param node - Node to check.
     */
    static isStringLiteral(node) {
        return node.getKind() === typescript_1.SyntaxKind.StringLiteral;
    }
    /**
     * Gets if the node is a SuperExpression.
     * @param node - Node to check.
     */
    static isSuperExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.SuperKeyword;
    }
    /**
     * Gets if the node is a SwitchStatement.
     * @param node - Node to check.
     */
    static isSwitchStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.SwitchStatement;
    }
    /**
     * Gets if the node is a SymbolKeyword.
     * @param node - Node to check.
     */
    static isSymbolKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.SymbolKeyword;
    }
    /**
     * Gets if the node is a SyntaxList.
     * @param node - Node to check.
     */
    static isSyntaxList(node) {
        return node.getKind() === typescript_1.SyntaxKind.SyntaxList;
    }
    /**
     * Gets if the node is a TaggedTemplateExpression.
     * @param node - Node to check.
     */
    static isTaggedTemplateExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.TaggedTemplateExpression;
    }
    /**
     * Gets if the node is a TemplateExpression.
     * @param node - Node to check.
     */
    static isTemplateExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.TemplateExpression;
    }
    /**
     * Gets if the node is a TemplateHead.
     * @param node - Node to check.
     */
    static isTemplateHead(node) {
        return node.getKind() === typescript_1.SyntaxKind.TemplateHead;
    }
    /**
     * Gets if the node is a TemplateMiddle.
     * @param node - Node to check.
     */
    static isTemplateMiddle(node) {
        return node.getKind() === typescript_1.SyntaxKind.TemplateMiddle;
    }
    /**
     * Gets if the node is a TemplateSpan.
     * @param node - Node to check.
     */
    static isTemplateSpan(node) {
        return node.getKind() === typescript_1.SyntaxKind.TemplateSpan;
    }
    /**
     * Gets if the node is a TemplateTail.
     * @param node - Node to check.
     */
    static isTemplateTail(node) {
        return node.getKind() === typescript_1.SyntaxKind.TemplateTail;
    }
    /**
     * Gets if the node is a TextInsertableNode.
     * @param node - Node to check.
     */
    static isTextInsertableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.SourceFile:
            case typescript_1.SyntaxKind.Block:
            case typescript_1.SyntaxKind.CaseBlock:
            case typescript_1.SyntaxKind.CaseClause:
            case typescript_1.SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a ThisExpression.
     * @param node - Node to check.
     */
    static isThisExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.ThisKeyword;
    }
    /**
     * Gets if the node is a ThisTypeNode.
     * @param node - Node to check.
     */
    static isThisTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.ThisType;
    }
    /**
     * Gets if the node is a ThrowStatement.
     * @param node - Node to check.
     */
    static isThrowStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.ThrowStatement;
    }
    /**
     * Gets if the node is a TrueKeyword.
     * @param node - Node to check.
     */
    static isTrueKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.TrueKeyword;
    }
    /**
     * Gets if the node is a TryStatement.
     * @param node - Node to check.
     */
    static isTryStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.TryStatement;
    }
    /**
     * Gets if the node is a TupleTypeNode.
     * @param node - Node to check.
     */
    static isTupleTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.TupleType;
    }
    /**
     * Gets if the node is a TypeAliasDeclaration.
     * @param node - Node to check.
     */
    static isTypeAliasDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.TypeAliasDeclaration;
    }
    /**
     * Gets if the node is a TypeArgumentedNode.
     * @param node - Node to check.
     */
    static isTypeArgumentedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.CallExpression:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.ImportType:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a TypeAssertion.
     * @param node - Node to check.
     */
    static isTypeAssertion(node) {
        return node.getKind() === typescript_1.SyntaxKind.TypeAssertionExpression;
    }
    /**
     * Gets if the node is a TypeElement.
     * @param node - Node to check.
     */
    static isTypeElement(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.IndexSignature:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a TypeElementMemberedNode.
     * @param node - Node to check.
     */
    static isTypeElementMemberedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a TypeLiteralNode.
     * @param node - Node to check.
     */
    static isTypeLiteralNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.TypeLiteral;
    }
    /**
     * Gets if the node is a TypeNode.
     * @param node - Node to check.
     */
    static isTypeNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.TypePredicate:
            case typescript_1.SyntaxKind.JSDocFunctionType:
            case typescript_1.SyntaxKind.JSDocSignature:
            case typescript_1.SyntaxKind.JSDocTypeExpression:
            case typescript_1.SyntaxKind.ArrayType:
            case typescript_1.SyntaxKind.ConditionalType:
            case typescript_1.SyntaxKind.ConstructorType:
            case typescript_1.SyntaxKind.ExpressionWithTypeArguments:
            case typescript_1.SyntaxKind.FunctionType:
            case typescript_1.SyntaxKind.ImportType:
            case typescript_1.SyntaxKind.IndexedAccessType:
            case typescript_1.SyntaxKind.InferType:
            case typescript_1.SyntaxKind.IntersectionType:
            case typescript_1.SyntaxKind.LiteralType:
            case typescript_1.SyntaxKind.ParenthesizedType:
            case typescript_1.SyntaxKind.ThisType:
            case typescript_1.SyntaxKind.TupleType:
            case typescript_1.SyntaxKind.TypeLiteral:
            case typescript_1.SyntaxKind.TypeReference:
            case typescript_1.SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a TypeOfExpression.
     * @param node - Node to check.
     */
    static isTypeOfExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.TypeOfExpression;
    }
    /**
     * Gets if the node is a TypeParameterDeclaration.
     * @param node - Node to check.
     */
    static isTypeParameterDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.TypeParameter;
    }
    /**
     * Gets if the node is a TypeParameteredNode.
     * @param node - Node to check.
     */
    static isTypeParameteredNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.ArrowFunction:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.FunctionType:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a TypeReferenceNode.
     * @param node - Node to check.
     */
    static isTypeReferenceNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.TypeReference;
    }
    /**
     * Gets if the node is a TypedNode.
     * @param node - Node to check.
     */
    static isTypedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.AsExpression:
            case typescript_1.SyntaxKind.TypeAssertionExpression:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
            case typescript_1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a UnaryExpression.
     * @param node - Node to check.
     */
    static isUnaryExpression(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.AwaitExpression:
            case typescript_1.SyntaxKind.CallExpression:
            case typescript_1.SyntaxKind.DeleteExpression:
            case typescript_1.SyntaxKind.ElementAccessExpression:
            case typescript_1.SyntaxKind.ImportKeyword:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.NonNullExpression:
            case typescript_1.SyntaxKind.PostfixUnaryExpression:
            case typescript_1.SyntaxKind.PrefixUnaryExpression:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.SuperKeyword:
            case typescript_1.SyntaxKind.ThisKeyword:
            case typescript_1.SyntaxKind.TypeAssertionExpression:
            case typescript_1.SyntaxKind.TypeOfExpression:
            case typescript_1.SyntaxKind.VoidExpression:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.JsxElement:
            case typescript_1.SyntaxKind.JsxFragment:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
            case typescript_1.SyntaxKind.FalseKeyword:
            case typescript_1.SyntaxKind.TrueKeyword:
            case typescript_1.SyntaxKind.NullKeyword:
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.ArrayLiteralExpression:
            case typescript_1.SyntaxKind.ObjectLiteralExpression:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case typescript_1.SyntaxKind.TaggedTemplateExpression:
            case typescript_1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a UnaryExpressionedNode.
     * @param node - Node to check.
     */
    static isUnaryExpressionedNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.AwaitExpression:
            case typescript_1.SyntaxKind.DeleteExpression:
            case typescript_1.SyntaxKind.TypeAssertionExpression:
            case typescript_1.SyntaxKind.TypeOfExpression:
            case typescript_1.SyntaxKind.VoidExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a UndefinedKeyword.
     * @param node - Node to check.
     */
    static isUndefinedKeyword(node) {
        return node.getKind() === typescript_1.SyntaxKind.UndefinedKeyword;
    }
    /**
     * Gets if the node is a UnionTypeNode.
     * @param node - Node to check.
     */
    static isUnionTypeNode(node) {
        return node.getKind() === typescript_1.SyntaxKind.UnionType;
    }
    /**
     * Gets if the node is a UnwrappableNode.
     * @param node - Node to check.
     */
    static isUnwrappableNode(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a UpdateExpression.
     * @param node - Node to check.
     */
    static isUpdateExpression(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassExpression:
            case typescript_1.SyntaxKind.Identifier:
            case typescript_1.SyntaxKind.CallExpression:
            case typescript_1.SyntaxKind.ElementAccessExpression:
            case typescript_1.SyntaxKind.ImportKeyword:
            case typescript_1.SyntaxKind.MetaProperty:
            case typescript_1.SyntaxKind.NewExpression:
            case typescript_1.SyntaxKind.NonNullExpression:
            case typescript_1.SyntaxKind.PropertyAccessExpression:
            case typescript_1.SyntaxKind.SuperKeyword:
            case typescript_1.SyntaxKind.ThisKeyword:
            case typescript_1.SyntaxKind.FunctionExpression:
            case typescript_1.SyntaxKind.JsxElement:
            case typescript_1.SyntaxKind.JsxFragment:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
            case typescript_1.SyntaxKind.FalseKeyword:
            case typescript_1.SyntaxKind.TrueKeyword:
            case typescript_1.SyntaxKind.NullKeyword:
            case typescript_1.SyntaxKind.NumericLiteral:
            case typescript_1.SyntaxKind.RegularExpressionLiteral:
            case typescript_1.SyntaxKind.StringLiteral:
            case typescript_1.SyntaxKind.ArrayLiteralExpression:
            case typescript_1.SyntaxKind.ObjectLiteralExpression:
            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case typescript_1.SyntaxKind.TaggedTemplateExpression:
            case typescript_1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets if the node is a VariableDeclaration.
     * @param node - Node to check.
     */
    static isVariableDeclaration(node) {
        return node.getKind() === typescript_1.SyntaxKind.VariableDeclaration;
    }
    /**
     * Gets if the node is a VariableDeclarationList.
     * @param node - Node to check.
     */
    static isVariableDeclarationList(node) {
        return node.getKind() === typescript_1.SyntaxKind.VariableDeclarationList;
    }
    /**
     * Gets if the node is a VariableStatement.
     * @param node - Node to check.
     */
    static isVariableStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.VariableStatement;
    }
    /**
     * Gets if the node is a VoidExpression.
     * @param node - Node to check.
     */
    static isVoidExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.VoidExpression;
    }
    /**
     * Gets if the node is a WhileStatement.
     * @param node - Node to check.
     */
    static isWhileStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.WhileStatement;
    }
    /**
     * Gets if the node is a WithStatement.
     * @param node - Node to check.
     */
    static isWithStatement(node) {
        return node.getKind() === typescript_1.SyntaxKind.WithStatement;
    }
    /**
     * Gets if the node is a YieldExpression.
     * @param node - Node to check.
     */
    static isYieldExpression(node) {
        return node.getKind() === typescript_1.SyntaxKind.YieldExpression;
    }
    /**
     * @internal
     */
    static _hasStructure(node) {
        switch (node.getKind()) {
            case typescript_1.SyntaxKind.ClassDeclaration:
            case typescript_1.SyntaxKind.Constructor:
            case typescript_1.SyntaxKind.GetAccessor:
            case typescript_1.SyntaxKind.MethodDeclaration:
            case typescript_1.SyntaxKind.PropertyDeclaration:
            case typescript_1.SyntaxKind.SetAccessor:
            case typescript_1.SyntaxKind.Decorator:
            case typescript_1.SyntaxKind.JSDocComment:
            case typescript_1.SyntaxKind.EnumDeclaration:
            case typescript_1.SyntaxKind.EnumMember:
            case typescript_1.SyntaxKind.FunctionDeclaration:
            case typescript_1.SyntaxKind.Parameter:
            case typescript_1.SyntaxKind.CallSignature:
            case typescript_1.SyntaxKind.ConstructSignature:
            case typescript_1.SyntaxKind.IndexSignature:
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.MethodSignature:
            case typescript_1.SyntaxKind.PropertySignature:
            case typescript_1.SyntaxKind.JsxAttribute:
            case typescript_1.SyntaxKind.JsxElement:
            case typescript_1.SyntaxKind.JsxSelfClosingElement:
            case typescript_1.SyntaxKind.JsxSpreadAttribute:
            case typescript_1.SyntaxKind.ExportAssignment:
            case typescript_1.SyntaxKind.ExportDeclaration:
            case typescript_1.SyntaxKind.ExportSpecifier:
            case typescript_1.SyntaxKind.ImportDeclaration:
            case typescript_1.SyntaxKind.ImportSpecifier:
            case typescript_1.SyntaxKind.ModuleDeclaration:
            case typescript_1.SyntaxKind.SourceFile:
            case typescript_1.SyntaxKind.VariableStatement:
            case typescript_1.SyntaxKind.TypeAliasDeclaration:
            case typescript_1.SyntaxKind.TypeParameter:
            case typescript_1.SyntaxKind.VariableDeclaration:
            case typescript_1.SyntaxKind.PropertyAssignment:
            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
            case typescript_1.SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    }
}
exports.TypeGuards = TypeGuards;
