"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../errors");
const isSpaces = /^ +$/;
const isWhitespace = /^\s*$/;
const startsWithNewLine = /^\r?\n/;
const endsWithNewLine = /\r?\n$/;
class StringUtils {
    constructor() {
    }
    static hasBom(text) {
        return text.charCodeAt(0) === 0xFEFF;
    }
    static stripBom(text) {
        if (StringUtils.hasBom(text))
            return text.slice(1);
        return text;
    }
    static isNullOrWhitespace(str) {
        return typeof str !== "string" || StringUtils.isWhitespace(str);
    }
    static isNullOrEmpty(str) {
        return typeof str !== "string" || str.length === 0;
    }
    static isWhitespace(str) {
        return isWhitespace.test(str);
    }
    static startsWithNewLine(str) {
        return startsWithNewLine.test(str);
    }
    static endsWithNewLine(str) {
        return endsWithNewLine.test(str);
    }
    static insertAtLastNonWhitespace(str, insertText) {
        let i = str.length;
        while (i > 0 && isWhitespace.test(str[i - 1]))
            i--;
        return str.substring(0, i) + insertText + str.substring(i);
    }
    static getLineNumberAtPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        // do not allocate a string in this method
        let count = 0;
        for (let i = 0; i < pos; i++) {
            if (str[i] === "\n" || (str[i] === "\r" && str[i + 1] !== "\n"))
                count++;
        }
        return count + 1; // convert count to line number
    }
    static getLengthFromLineStartAtPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        return pos - StringUtils.getLineStartFromPos(str, pos);
    }
    static getLineStartFromPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        while (pos > 0) {
            const previousChar = str[pos - 1];
            if (previousChar === "\n" || previousChar === "\r")
                break;
            pos--;
        }
        return pos;
    }
    static getLineEndFromPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        while (pos < str.length) {
            const currentChar = str[pos];
            if (currentChar === "\n" || currentChar === "\r")
                break;
            pos++;
        }
        return pos;
    }
    static escapeForWithinString(str, quoteKind) {
        return StringUtils.escapeChar(str, quoteKind).replace(/(\r?\n)/g, "\\$1");
    }
    /**
     * Escapes all the occurrences of the char in the string.
     */
    static escapeChar(str, char) {
        if (char.length !== 1)
            throw new errors.InvalidOperationError(`Specified char must be one character long.`);
        let result = "";
        for (let i = 0; i < str.length; i++) {
            if (str[i] === char)
                result += "\\";
            result += str[i];
        }
        return result;
    }
    static indent(str, times, indentText, isInStringAtPos) {
        // todo: unit test this (right now it's somewhat tested indirectly)
        const unIndentRegex = times > 0 ? undefined : new RegExp(getDeIndentRegexText());
        const newLines = [];
        let pos = 0;
        for (const line of str.split("\n")) {
            if (isInStringAtPos(pos))
                newLines.push(line);
            else if (times > 0)
                newLines.push(indentText.repeat(times) + line);
            else // negative
                newLines.push(line.replace(unIndentRegex, ""));
            pos += line.length + 1; // +1 for \n char
        }
        return newLines.join("\n");
        function getDeIndentRegexText() {
            let text = "^";
            for (let i = 0; i < Math.abs(times); i++) {
                text += "(";
                if (isSpaces.test(indentText)) {
                    // the optional string makes it possible to unindent when a line doesn't have the full number of spaces
                    for (let j = 0; j < indentText.length; j++)
                        text += " ?";
                }
                else
                    text += indentText;
                text += "|\t)?";
            }
            return text;
        }
    }
}
exports.StringUtils = StringUtils;
