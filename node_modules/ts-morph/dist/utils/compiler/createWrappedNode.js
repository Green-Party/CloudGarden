"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../errors");
const fileSystem_1 = require("../../fileSystem");
const ProjectContext_1 = require("../../ProjectContext");
const typescript_1 = require("../../typescript");
/**
 * Creates a wrapped node from a compiler node.
 * @param node - Node to create a wrapped node from.
 * @param info - Info for creating the wrapped node.
 */
function createWrappedNode(node, opts = {}) {
    const { compilerOptions = {}, sourceFile, typeChecker } = opts;
    const projectContext = new ProjectContext_1.ProjectContext(undefined, new fileSystem_1.FileSystemWrapper(new fileSystem_1.DefaultFileSystemHost()), compilerOptions, { createLanguageService: false, typeChecker });
    const wrappedSourceFile = projectContext.compilerFactory.getSourceFile(getSourceFileNode(), { markInProject: true });
    return projectContext.compilerFactory.getNodeFromCompilerNode(node, wrappedSourceFile);
    function getSourceFileNode() {
        return sourceFile == null ? getSourceFileFromNode(node) : sourceFile;
    }
    function getSourceFileFromNode(compilerNode) {
        if (compilerNode.kind === typescript_1.SyntaxKind.SourceFile)
            return compilerNode;
        if (compilerNode.parent == null)
            throw new errors.InvalidOperationError("Please ensure the node was created from a source file with 'setParentNodes' set to 'true'.");
        let parent = compilerNode;
        while (parent.parent != null)
            parent = parent.parent;
        if (parent.kind !== typescript_1.SyntaxKind.SourceFile)
            throw new errors.NotImplementedError("For some reason the top parent was not a source file.");
        return parent;
    }
}
exports.createWrappedNode = createWrappedNode;
